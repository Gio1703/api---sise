
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model tipo_documentos
 * 
 */
export type tipo_documentos = $Result.DefaultSelection<Prisma.$tipo_documentosPayload>
/**
 * Model citas
 * 
 */
export type citas = $Result.DefaultSelection<Prisma.$citasPayload>
/**
 * Model especialidades
 * 
 */
export type especialidades = $Result.DefaultSelection<Prisma.$especialidadesPayload>
/**
 * Model horarios
 * 
 */
export type horarios = $Result.DefaultSelection<Prisma.$horariosPayload>
/**
 * Model medicos
 * 
 */
export type medicos = $Result.DefaultSelection<Prisma.$medicosPayload>
/**
 * Model pacientes
 * 
 */
export type pacientes = $Result.DefaultSelection<Prisma.$pacientesPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tipo_documentos
 * const tipo_documentos = await prisma.tipo_documentos.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tipo_documentos
   * const tipo_documentos = await prisma.tipo_documentos.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.tipo_documentos`: Exposes CRUD operations for the **tipo_documentos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tipo_documentos
    * const tipo_documentos = await prisma.tipo_documentos.findMany()
    * ```
    */
  get tipo_documentos(): Prisma.tipo_documentosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.citas`: Exposes CRUD operations for the **citas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Citas
    * const citas = await prisma.citas.findMany()
    * ```
    */
  get citas(): Prisma.citasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.especialidades`: Exposes CRUD operations for the **especialidades** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Especialidades
    * const especialidades = await prisma.especialidades.findMany()
    * ```
    */
  get especialidades(): Prisma.especialidadesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.horarios`: Exposes CRUD operations for the **horarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Horarios
    * const horarios = await prisma.horarios.findMany()
    * ```
    */
  get horarios(): Prisma.horariosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicos`: Exposes CRUD operations for the **medicos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medicos
    * const medicos = await prisma.medicos.findMany()
    * ```
    */
  get medicos(): Prisma.medicosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pacientes`: Exposes CRUD operations for the **pacientes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pacientes
    * const pacientes = await prisma.pacientes.findMany()
    * ```
    */
  get pacientes(): Prisma.pacientesDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.1
   * Query Engine version: 9b628578b3b7cae625e8c927178f15a170e74a9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    tipo_documentos: 'tipo_documentos',
    citas: 'citas',
    especialidades: 'especialidades',
    horarios: 'horarios',
    medicos: 'medicos',
    pacientes: 'pacientes'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "tipo_documentos" | "citas" | "especialidades" | "horarios" | "medicos" | "pacientes"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      tipo_documentos: {
        payload: Prisma.$tipo_documentosPayload<ExtArgs>
        fields: Prisma.tipo_documentosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tipo_documentosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipo_documentosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tipo_documentosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipo_documentosPayload>
          }
          findFirst: {
            args: Prisma.tipo_documentosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipo_documentosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tipo_documentosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipo_documentosPayload>
          }
          findMany: {
            args: Prisma.tipo_documentosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipo_documentosPayload>[]
          }
          create: {
            args: Prisma.tipo_documentosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipo_documentosPayload>
          }
          createMany: {
            args: Prisma.tipo_documentosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tipo_documentosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipo_documentosPayload>[]
          }
          delete: {
            args: Prisma.tipo_documentosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipo_documentosPayload>
          }
          update: {
            args: Prisma.tipo_documentosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipo_documentosPayload>
          }
          deleteMany: {
            args: Prisma.tipo_documentosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tipo_documentosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tipo_documentosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipo_documentosPayload>[]
          }
          upsert: {
            args: Prisma.tipo_documentosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipo_documentosPayload>
          }
          aggregate: {
            args: Prisma.Tipo_documentosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipo_documentos>
          }
          groupBy: {
            args: Prisma.tipo_documentosGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tipo_documentosGroupByOutputType>[]
          }
          count: {
            args: Prisma.tipo_documentosCountArgs<ExtArgs>
            result: $Utils.Optional<Tipo_documentosCountAggregateOutputType> | number
          }
        }
      }
      citas: {
        payload: Prisma.$citasPayload<ExtArgs>
        fields: Prisma.citasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.citasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.citasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citasPayload>
          }
          findFirst: {
            args: Prisma.citasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.citasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citasPayload>
          }
          findMany: {
            args: Prisma.citasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citasPayload>[]
          }
          create: {
            args: Prisma.citasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citasPayload>
          }
          createMany: {
            args: Prisma.citasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.citasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citasPayload>[]
          }
          delete: {
            args: Prisma.citasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citasPayload>
          }
          update: {
            args: Prisma.citasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citasPayload>
          }
          deleteMany: {
            args: Prisma.citasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.citasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.citasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citasPayload>[]
          }
          upsert: {
            args: Prisma.citasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citasPayload>
          }
          aggregate: {
            args: Prisma.CitasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCitas>
          }
          groupBy: {
            args: Prisma.citasGroupByArgs<ExtArgs>
            result: $Utils.Optional<CitasGroupByOutputType>[]
          }
          count: {
            args: Prisma.citasCountArgs<ExtArgs>
            result: $Utils.Optional<CitasCountAggregateOutputType> | number
          }
        }
      }
      especialidades: {
        payload: Prisma.$especialidadesPayload<ExtArgs>
        fields: Prisma.especialidadesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.especialidadesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.especialidadesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadesPayload>
          }
          findFirst: {
            args: Prisma.especialidadesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.especialidadesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadesPayload>
          }
          findMany: {
            args: Prisma.especialidadesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadesPayload>[]
          }
          create: {
            args: Prisma.especialidadesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadesPayload>
          }
          createMany: {
            args: Prisma.especialidadesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.especialidadesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadesPayload>[]
          }
          delete: {
            args: Prisma.especialidadesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadesPayload>
          }
          update: {
            args: Prisma.especialidadesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadesPayload>
          }
          deleteMany: {
            args: Prisma.especialidadesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.especialidadesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.especialidadesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadesPayload>[]
          }
          upsert: {
            args: Prisma.especialidadesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadesPayload>
          }
          aggregate: {
            args: Prisma.EspecialidadesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEspecialidades>
          }
          groupBy: {
            args: Prisma.especialidadesGroupByArgs<ExtArgs>
            result: $Utils.Optional<EspecialidadesGroupByOutputType>[]
          }
          count: {
            args: Prisma.especialidadesCountArgs<ExtArgs>
            result: $Utils.Optional<EspecialidadesCountAggregateOutputType> | number
          }
        }
      }
      horarios: {
        payload: Prisma.$horariosPayload<ExtArgs>
        fields: Prisma.horariosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.horariosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horariosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.horariosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horariosPayload>
          }
          findFirst: {
            args: Prisma.horariosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horariosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.horariosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horariosPayload>
          }
          findMany: {
            args: Prisma.horariosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horariosPayload>[]
          }
          create: {
            args: Prisma.horariosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horariosPayload>
          }
          createMany: {
            args: Prisma.horariosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.horariosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horariosPayload>[]
          }
          delete: {
            args: Prisma.horariosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horariosPayload>
          }
          update: {
            args: Prisma.horariosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horariosPayload>
          }
          deleteMany: {
            args: Prisma.horariosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.horariosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.horariosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horariosPayload>[]
          }
          upsert: {
            args: Prisma.horariosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horariosPayload>
          }
          aggregate: {
            args: Prisma.HorariosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHorarios>
          }
          groupBy: {
            args: Prisma.horariosGroupByArgs<ExtArgs>
            result: $Utils.Optional<HorariosGroupByOutputType>[]
          }
          count: {
            args: Prisma.horariosCountArgs<ExtArgs>
            result: $Utils.Optional<HorariosCountAggregateOutputType> | number
          }
        }
      }
      medicos: {
        payload: Prisma.$medicosPayload<ExtArgs>
        fields: Prisma.medicosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.medicosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.medicosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicosPayload>
          }
          findFirst: {
            args: Prisma.medicosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.medicosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicosPayload>
          }
          findMany: {
            args: Prisma.medicosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicosPayload>[]
          }
          create: {
            args: Prisma.medicosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicosPayload>
          }
          createMany: {
            args: Prisma.medicosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.medicosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicosPayload>[]
          }
          delete: {
            args: Prisma.medicosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicosPayload>
          }
          update: {
            args: Prisma.medicosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicosPayload>
          }
          deleteMany: {
            args: Prisma.medicosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.medicosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.medicosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicosPayload>[]
          }
          upsert: {
            args: Prisma.medicosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicosPayload>
          }
          aggregate: {
            args: Prisma.MedicosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicos>
          }
          groupBy: {
            args: Prisma.medicosGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicosGroupByOutputType>[]
          }
          count: {
            args: Prisma.medicosCountArgs<ExtArgs>
            result: $Utils.Optional<MedicosCountAggregateOutputType> | number
          }
        }
      }
      pacientes: {
        payload: Prisma.$pacientesPayload<ExtArgs>
        fields: Prisma.pacientesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pacientesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pacientesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientesPayload>
          }
          findFirst: {
            args: Prisma.pacientesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pacientesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientesPayload>
          }
          findMany: {
            args: Prisma.pacientesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientesPayload>[]
          }
          create: {
            args: Prisma.pacientesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientesPayload>
          }
          createMany: {
            args: Prisma.pacientesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pacientesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientesPayload>[]
          }
          delete: {
            args: Prisma.pacientesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientesPayload>
          }
          update: {
            args: Prisma.pacientesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientesPayload>
          }
          deleteMany: {
            args: Prisma.pacientesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pacientesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.pacientesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientesPayload>[]
          }
          upsert: {
            args: Prisma.pacientesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientesPayload>
          }
          aggregate: {
            args: Prisma.PacientesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePacientes>
          }
          groupBy: {
            args: Prisma.pacientesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PacientesGroupByOutputType>[]
          }
          count: {
            args: Prisma.pacientesCountArgs<ExtArgs>
            result: $Utils.Optional<PacientesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    tipo_documentos?: tipo_documentosOmit
    citas?: citasOmit
    especialidades?: especialidadesOmit
    horarios?: horariosOmit
    medicos?: medicosOmit
    pacientes?: pacientesOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Tipo_documentosCountOutputType
   */

  export type Tipo_documentosCountOutputType = {
    pacientes: number
  }

  export type Tipo_documentosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pacientes?: boolean | Tipo_documentosCountOutputTypeCountPacientesArgs
  }

  // Custom InputTypes
  /**
   * Tipo_documentosCountOutputType without action
   */
  export type Tipo_documentosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_documentosCountOutputType
     */
    select?: Tipo_documentosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Tipo_documentosCountOutputType without action
   */
  export type Tipo_documentosCountOutputTypeCountPacientesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pacientesWhereInput
  }


  /**
   * Count Type EspecialidadesCountOutputType
   */

  export type EspecialidadesCountOutputType = {
    medicos: number
  }

  export type EspecialidadesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicos?: boolean | EspecialidadesCountOutputTypeCountMedicosArgs
  }

  // Custom InputTypes
  /**
   * EspecialidadesCountOutputType without action
   */
  export type EspecialidadesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecialidadesCountOutputType
     */
    select?: EspecialidadesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EspecialidadesCountOutputType without action
   */
  export type EspecialidadesCountOutputTypeCountMedicosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medicosWhereInput
  }


  /**
   * Count Type MedicosCountOutputType
   */

  export type MedicosCountOutputType = {
    citas: number
    horarios: number
  }

  export type MedicosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    citas?: boolean | MedicosCountOutputTypeCountCitasArgs
    horarios?: boolean | MedicosCountOutputTypeCountHorariosArgs
  }

  // Custom InputTypes
  /**
   * MedicosCountOutputType without action
   */
  export type MedicosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicosCountOutputType
     */
    select?: MedicosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MedicosCountOutputType without action
   */
  export type MedicosCountOutputTypeCountCitasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: citasWhereInput
  }

  /**
   * MedicosCountOutputType without action
   */
  export type MedicosCountOutputTypeCountHorariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: horariosWhereInput
  }


  /**
   * Count Type PacientesCountOutputType
   */

  export type PacientesCountOutputType = {
    citas: number
  }

  export type PacientesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    citas?: boolean | PacientesCountOutputTypeCountCitasArgs
  }

  // Custom InputTypes
  /**
   * PacientesCountOutputType without action
   */
  export type PacientesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PacientesCountOutputType
     */
    select?: PacientesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PacientesCountOutputType without action
   */
  export type PacientesCountOutputTypeCountCitasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: citasWhereInput
  }


  /**
   * Models
   */

  /**
   * Model tipo_documentos
   */

  export type AggregateTipo_documentos = {
    _count: Tipo_documentosCountAggregateOutputType | null
    _avg: Tipo_documentosAvgAggregateOutputType | null
    _sum: Tipo_documentosSumAggregateOutputType | null
    _min: Tipo_documentosMinAggregateOutputType | null
    _max: Tipo_documentosMaxAggregateOutputType | null
  }

  export type Tipo_documentosAvgAggregateOutputType = {
    id_tipo_documento: number | null
  }

  export type Tipo_documentosSumAggregateOutputType = {
    id_tipo_documento: number | null
  }

  export type Tipo_documentosMinAggregateOutputType = {
    id_tipo_documento: number | null
    nombre: string | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_actualizacion: Date | null
  }

  export type Tipo_documentosMaxAggregateOutputType = {
    id_tipo_documento: number | null
    nombre: string | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_actualizacion: Date | null
  }

  export type Tipo_documentosCountAggregateOutputType = {
    id_tipo_documento: number
    nombre: number
    estado_auditoria: number
    fecha_creacion: number
    fecha_actualizacion: number
    _all: number
  }


  export type Tipo_documentosAvgAggregateInputType = {
    id_tipo_documento?: true
  }

  export type Tipo_documentosSumAggregateInputType = {
    id_tipo_documento?: true
  }

  export type Tipo_documentosMinAggregateInputType = {
    id_tipo_documento?: true
    nombre?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_actualizacion?: true
  }

  export type Tipo_documentosMaxAggregateInputType = {
    id_tipo_documento?: true
    nombre?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_actualizacion?: true
  }

  export type Tipo_documentosCountAggregateInputType = {
    id_tipo_documento?: true
    nombre?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_actualizacion?: true
    _all?: true
  }

  export type Tipo_documentosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipo_documentos to aggregate.
     */
    where?: tipo_documentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_documentos to fetch.
     */
    orderBy?: tipo_documentosOrderByWithRelationInput | tipo_documentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tipo_documentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_documentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tipo_documentos
    **/
    _count?: true | Tipo_documentosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tipo_documentosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tipo_documentosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tipo_documentosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tipo_documentosMaxAggregateInputType
  }

  export type GetTipo_documentosAggregateType<T extends Tipo_documentosAggregateArgs> = {
        [P in keyof T & keyof AggregateTipo_documentos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipo_documentos[P]>
      : GetScalarType<T[P], AggregateTipo_documentos[P]>
  }




  export type tipo_documentosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tipo_documentosWhereInput
    orderBy?: tipo_documentosOrderByWithAggregationInput | tipo_documentosOrderByWithAggregationInput[]
    by: Tipo_documentosScalarFieldEnum[] | Tipo_documentosScalarFieldEnum
    having?: tipo_documentosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tipo_documentosCountAggregateInputType | true
    _avg?: Tipo_documentosAvgAggregateInputType
    _sum?: Tipo_documentosSumAggregateInputType
    _min?: Tipo_documentosMinAggregateInputType
    _max?: Tipo_documentosMaxAggregateInputType
  }

  export type Tipo_documentosGroupByOutputType = {
    id_tipo_documento: number
    nombre: string
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_actualizacion: Date | null
    _count: Tipo_documentosCountAggregateOutputType | null
    _avg: Tipo_documentosAvgAggregateOutputType | null
    _sum: Tipo_documentosSumAggregateOutputType | null
    _min: Tipo_documentosMinAggregateOutputType | null
    _max: Tipo_documentosMaxAggregateOutputType | null
  }

  type GetTipo_documentosGroupByPayload<T extends tipo_documentosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tipo_documentosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tipo_documentosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tipo_documentosGroupByOutputType[P]>
            : GetScalarType<T[P], Tipo_documentosGroupByOutputType[P]>
        }
      >
    >


  export type tipo_documentosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tipo_documento?: boolean
    nombre?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_actualizacion?: boolean
    pacientes?: boolean | tipo_documentos$pacientesArgs<ExtArgs>
    _count?: boolean | Tipo_documentosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipo_documentos"]>

  export type tipo_documentosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tipo_documento?: boolean
    nombre?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_actualizacion?: boolean
  }, ExtArgs["result"]["tipo_documentos"]>

  export type tipo_documentosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tipo_documento?: boolean
    nombre?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_actualizacion?: boolean
  }, ExtArgs["result"]["tipo_documentos"]>

  export type tipo_documentosSelectScalar = {
    id_tipo_documento?: boolean
    nombre?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_actualizacion?: boolean
  }

  export type tipo_documentosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_tipo_documento" | "nombre" | "estado_auditoria" | "fecha_creacion" | "fecha_actualizacion", ExtArgs["result"]["tipo_documentos"]>
  export type tipo_documentosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pacientes?: boolean | tipo_documentos$pacientesArgs<ExtArgs>
    _count?: boolean | Tipo_documentosCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tipo_documentosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type tipo_documentosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $tipo_documentosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tipo_documentos"
    objects: {
      pacientes: Prisma.$pacientesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_tipo_documento: number
      nombre: string
      estado_auditoria: string | null
      fecha_creacion: Date | null
      fecha_actualizacion: Date | null
    }, ExtArgs["result"]["tipo_documentos"]>
    composites: {}
  }

  type tipo_documentosGetPayload<S extends boolean | null | undefined | tipo_documentosDefaultArgs> = $Result.GetResult<Prisma.$tipo_documentosPayload, S>

  type tipo_documentosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tipo_documentosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tipo_documentosCountAggregateInputType | true
    }

  export interface tipo_documentosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tipo_documentos'], meta: { name: 'tipo_documentos' } }
    /**
     * Find zero or one Tipo_documentos that matches the filter.
     * @param {tipo_documentosFindUniqueArgs} args - Arguments to find a Tipo_documentos
     * @example
     * // Get one Tipo_documentos
     * const tipo_documentos = await prisma.tipo_documentos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tipo_documentosFindUniqueArgs>(args: SelectSubset<T, tipo_documentosFindUniqueArgs<ExtArgs>>): Prisma__tipo_documentosClient<$Result.GetResult<Prisma.$tipo_documentosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tipo_documentos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tipo_documentosFindUniqueOrThrowArgs} args - Arguments to find a Tipo_documentos
     * @example
     * // Get one Tipo_documentos
     * const tipo_documentos = await prisma.tipo_documentos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tipo_documentosFindUniqueOrThrowArgs>(args: SelectSubset<T, tipo_documentosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tipo_documentosClient<$Result.GetResult<Prisma.$tipo_documentosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tipo_documentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_documentosFindFirstArgs} args - Arguments to find a Tipo_documentos
     * @example
     * // Get one Tipo_documentos
     * const tipo_documentos = await prisma.tipo_documentos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tipo_documentosFindFirstArgs>(args?: SelectSubset<T, tipo_documentosFindFirstArgs<ExtArgs>>): Prisma__tipo_documentosClient<$Result.GetResult<Prisma.$tipo_documentosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tipo_documentos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_documentosFindFirstOrThrowArgs} args - Arguments to find a Tipo_documentos
     * @example
     * // Get one Tipo_documentos
     * const tipo_documentos = await prisma.tipo_documentos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tipo_documentosFindFirstOrThrowArgs>(args?: SelectSubset<T, tipo_documentosFindFirstOrThrowArgs<ExtArgs>>): Prisma__tipo_documentosClient<$Result.GetResult<Prisma.$tipo_documentosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tipo_documentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_documentosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tipo_documentos
     * const tipo_documentos = await prisma.tipo_documentos.findMany()
     * 
     * // Get first 10 Tipo_documentos
     * const tipo_documentos = await prisma.tipo_documentos.findMany({ take: 10 })
     * 
     * // Only select the `id_tipo_documento`
     * const tipo_documentosWithId_tipo_documentoOnly = await prisma.tipo_documentos.findMany({ select: { id_tipo_documento: true } })
     * 
     */
    findMany<T extends tipo_documentosFindManyArgs>(args?: SelectSubset<T, tipo_documentosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipo_documentosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tipo_documentos.
     * @param {tipo_documentosCreateArgs} args - Arguments to create a Tipo_documentos.
     * @example
     * // Create one Tipo_documentos
     * const Tipo_documentos = await prisma.tipo_documentos.create({
     *   data: {
     *     // ... data to create a Tipo_documentos
     *   }
     * })
     * 
     */
    create<T extends tipo_documentosCreateArgs>(args: SelectSubset<T, tipo_documentosCreateArgs<ExtArgs>>): Prisma__tipo_documentosClient<$Result.GetResult<Prisma.$tipo_documentosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tipo_documentos.
     * @param {tipo_documentosCreateManyArgs} args - Arguments to create many Tipo_documentos.
     * @example
     * // Create many Tipo_documentos
     * const tipo_documentos = await prisma.tipo_documentos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tipo_documentosCreateManyArgs>(args?: SelectSubset<T, tipo_documentosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tipo_documentos and returns the data saved in the database.
     * @param {tipo_documentosCreateManyAndReturnArgs} args - Arguments to create many Tipo_documentos.
     * @example
     * // Create many Tipo_documentos
     * const tipo_documentos = await prisma.tipo_documentos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tipo_documentos and only return the `id_tipo_documento`
     * const tipo_documentosWithId_tipo_documentoOnly = await prisma.tipo_documentos.createManyAndReturn({
     *   select: { id_tipo_documento: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tipo_documentosCreateManyAndReturnArgs>(args?: SelectSubset<T, tipo_documentosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipo_documentosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tipo_documentos.
     * @param {tipo_documentosDeleteArgs} args - Arguments to delete one Tipo_documentos.
     * @example
     * // Delete one Tipo_documentos
     * const Tipo_documentos = await prisma.tipo_documentos.delete({
     *   where: {
     *     // ... filter to delete one Tipo_documentos
     *   }
     * })
     * 
     */
    delete<T extends tipo_documentosDeleteArgs>(args: SelectSubset<T, tipo_documentosDeleteArgs<ExtArgs>>): Prisma__tipo_documentosClient<$Result.GetResult<Prisma.$tipo_documentosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tipo_documentos.
     * @param {tipo_documentosUpdateArgs} args - Arguments to update one Tipo_documentos.
     * @example
     * // Update one Tipo_documentos
     * const tipo_documentos = await prisma.tipo_documentos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tipo_documentosUpdateArgs>(args: SelectSubset<T, tipo_documentosUpdateArgs<ExtArgs>>): Prisma__tipo_documentosClient<$Result.GetResult<Prisma.$tipo_documentosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tipo_documentos.
     * @param {tipo_documentosDeleteManyArgs} args - Arguments to filter Tipo_documentos to delete.
     * @example
     * // Delete a few Tipo_documentos
     * const { count } = await prisma.tipo_documentos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tipo_documentosDeleteManyArgs>(args?: SelectSubset<T, tipo_documentosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tipo_documentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_documentosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tipo_documentos
     * const tipo_documentos = await prisma.tipo_documentos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tipo_documentosUpdateManyArgs>(args: SelectSubset<T, tipo_documentosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tipo_documentos and returns the data updated in the database.
     * @param {tipo_documentosUpdateManyAndReturnArgs} args - Arguments to update many Tipo_documentos.
     * @example
     * // Update many Tipo_documentos
     * const tipo_documentos = await prisma.tipo_documentos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tipo_documentos and only return the `id_tipo_documento`
     * const tipo_documentosWithId_tipo_documentoOnly = await prisma.tipo_documentos.updateManyAndReturn({
     *   select: { id_tipo_documento: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tipo_documentosUpdateManyAndReturnArgs>(args: SelectSubset<T, tipo_documentosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipo_documentosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tipo_documentos.
     * @param {tipo_documentosUpsertArgs} args - Arguments to update or create a Tipo_documentos.
     * @example
     * // Update or create a Tipo_documentos
     * const tipo_documentos = await prisma.tipo_documentos.upsert({
     *   create: {
     *     // ... data to create a Tipo_documentos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tipo_documentos we want to update
     *   }
     * })
     */
    upsert<T extends tipo_documentosUpsertArgs>(args: SelectSubset<T, tipo_documentosUpsertArgs<ExtArgs>>): Prisma__tipo_documentosClient<$Result.GetResult<Prisma.$tipo_documentosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tipo_documentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_documentosCountArgs} args - Arguments to filter Tipo_documentos to count.
     * @example
     * // Count the number of Tipo_documentos
     * const count = await prisma.tipo_documentos.count({
     *   where: {
     *     // ... the filter for the Tipo_documentos we want to count
     *   }
     * })
    **/
    count<T extends tipo_documentosCountArgs>(
      args?: Subset<T, tipo_documentosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tipo_documentosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tipo_documentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_documentosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tipo_documentosAggregateArgs>(args: Subset<T, Tipo_documentosAggregateArgs>): Prisma.PrismaPromise<GetTipo_documentosAggregateType<T>>

    /**
     * Group by Tipo_documentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_documentosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tipo_documentosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tipo_documentosGroupByArgs['orderBy'] }
        : { orderBy?: tipo_documentosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tipo_documentosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipo_documentosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tipo_documentos model
   */
  readonly fields: tipo_documentosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tipo_documentos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tipo_documentosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pacientes<T extends tipo_documentos$pacientesArgs<ExtArgs> = {}>(args?: Subset<T, tipo_documentos$pacientesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pacientesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tipo_documentos model
   */
  interface tipo_documentosFieldRefs {
    readonly id_tipo_documento: FieldRef<"tipo_documentos", 'Int'>
    readonly nombre: FieldRef<"tipo_documentos", 'String'>
    readonly estado_auditoria: FieldRef<"tipo_documentos", 'String'>
    readonly fecha_creacion: FieldRef<"tipo_documentos", 'DateTime'>
    readonly fecha_actualizacion: FieldRef<"tipo_documentos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tipo_documentos findUnique
   */
  export type tipo_documentosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_documentos
     */
    select?: tipo_documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipo_documentos
     */
    omit?: tipo_documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipo_documentosInclude<ExtArgs> | null
    /**
     * Filter, which tipo_documentos to fetch.
     */
    where: tipo_documentosWhereUniqueInput
  }

  /**
   * tipo_documentos findUniqueOrThrow
   */
  export type tipo_documentosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_documentos
     */
    select?: tipo_documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipo_documentos
     */
    omit?: tipo_documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipo_documentosInclude<ExtArgs> | null
    /**
     * Filter, which tipo_documentos to fetch.
     */
    where: tipo_documentosWhereUniqueInput
  }

  /**
   * tipo_documentos findFirst
   */
  export type tipo_documentosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_documentos
     */
    select?: tipo_documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipo_documentos
     */
    omit?: tipo_documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipo_documentosInclude<ExtArgs> | null
    /**
     * Filter, which tipo_documentos to fetch.
     */
    where?: tipo_documentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_documentos to fetch.
     */
    orderBy?: tipo_documentosOrderByWithRelationInput | tipo_documentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipo_documentos.
     */
    cursor?: tipo_documentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_documentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipo_documentos.
     */
    distinct?: Tipo_documentosScalarFieldEnum | Tipo_documentosScalarFieldEnum[]
  }

  /**
   * tipo_documentos findFirstOrThrow
   */
  export type tipo_documentosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_documentos
     */
    select?: tipo_documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipo_documentos
     */
    omit?: tipo_documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipo_documentosInclude<ExtArgs> | null
    /**
     * Filter, which tipo_documentos to fetch.
     */
    where?: tipo_documentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_documentos to fetch.
     */
    orderBy?: tipo_documentosOrderByWithRelationInput | tipo_documentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipo_documentos.
     */
    cursor?: tipo_documentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_documentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipo_documentos.
     */
    distinct?: Tipo_documentosScalarFieldEnum | Tipo_documentosScalarFieldEnum[]
  }

  /**
   * tipo_documentos findMany
   */
  export type tipo_documentosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_documentos
     */
    select?: tipo_documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipo_documentos
     */
    omit?: tipo_documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipo_documentosInclude<ExtArgs> | null
    /**
     * Filter, which tipo_documentos to fetch.
     */
    where?: tipo_documentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_documentos to fetch.
     */
    orderBy?: tipo_documentosOrderByWithRelationInput | tipo_documentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tipo_documentos.
     */
    cursor?: tipo_documentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_documentos.
     */
    skip?: number
    distinct?: Tipo_documentosScalarFieldEnum | Tipo_documentosScalarFieldEnum[]
  }

  /**
   * tipo_documentos create
   */
  export type tipo_documentosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_documentos
     */
    select?: tipo_documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipo_documentos
     */
    omit?: tipo_documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipo_documentosInclude<ExtArgs> | null
    /**
     * The data needed to create a tipo_documentos.
     */
    data: XOR<tipo_documentosCreateInput, tipo_documentosUncheckedCreateInput>
  }

  /**
   * tipo_documentos createMany
   */
  export type tipo_documentosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tipo_documentos.
     */
    data: tipo_documentosCreateManyInput | tipo_documentosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tipo_documentos createManyAndReturn
   */
  export type tipo_documentosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_documentos
     */
    select?: tipo_documentosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tipo_documentos
     */
    omit?: tipo_documentosOmit<ExtArgs> | null
    /**
     * The data used to create many tipo_documentos.
     */
    data: tipo_documentosCreateManyInput | tipo_documentosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tipo_documentos update
   */
  export type tipo_documentosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_documentos
     */
    select?: tipo_documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipo_documentos
     */
    omit?: tipo_documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipo_documentosInclude<ExtArgs> | null
    /**
     * The data needed to update a tipo_documentos.
     */
    data: XOR<tipo_documentosUpdateInput, tipo_documentosUncheckedUpdateInput>
    /**
     * Choose, which tipo_documentos to update.
     */
    where: tipo_documentosWhereUniqueInput
  }

  /**
   * tipo_documentos updateMany
   */
  export type tipo_documentosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tipo_documentos.
     */
    data: XOR<tipo_documentosUpdateManyMutationInput, tipo_documentosUncheckedUpdateManyInput>
    /**
     * Filter which tipo_documentos to update
     */
    where?: tipo_documentosWhereInput
    /**
     * Limit how many tipo_documentos to update.
     */
    limit?: number
  }

  /**
   * tipo_documentos updateManyAndReturn
   */
  export type tipo_documentosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_documentos
     */
    select?: tipo_documentosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tipo_documentos
     */
    omit?: tipo_documentosOmit<ExtArgs> | null
    /**
     * The data used to update tipo_documentos.
     */
    data: XOR<tipo_documentosUpdateManyMutationInput, tipo_documentosUncheckedUpdateManyInput>
    /**
     * Filter which tipo_documentos to update
     */
    where?: tipo_documentosWhereInput
    /**
     * Limit how many tipo_documentos to update.
     */
    limit?: number
  }

  /**
   * tipo_documentos upsert
   */
  export type tipo_documentosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_documentos
     */
    select?: tipo_documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipo_documentos
     */
    omit?: tipo_documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipo_documentosInclude<ExtArgs> | null
    /**
     * The filter to search for the tipo_documentos to update in case it exists.
     */
    where: tipo_documentosWhereUniqueInput
    /**
     * In case the tipo_documentos found by the `where` argument doesn't exist, create a new tipo_documentos with this data.
     */
    create: XOR<tipo_documentosCreateInput, tipo_documentosUncheckedCreateInput>
    /**
     * In case the tipo_documentos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tipo_documentosUpdateInput, tipo_documentosUncheckedUpdateInput>
  }

  /**
   * tipo_documentos delete
   */
  export type tipo_documentosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_documentos
     */
    select?: tipo_documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipo_documentos
     */
    omit?: tipo_documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipo_documentosInclude<ExtArgs> | null
    /**
     * Filter which tipo_documentos to delete.
     */
    where: tipo_documentosWhereUniqueInput
  }

  /**
   * tipo_documentos deleteMany
   */
  export type tipo_documentosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipo_documentos to delete
     */
    where?: tipo_documentosWhereInput
    /**
     * Limit how many tipo_documentos to delete.
     */
    limit?: number
  }

  /**
   * tipo_documentos.pacientes
   */
  export type tipo_documentos$pacientesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacientes
     */
    select?: pacientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacientes
     */
    omit?: pacientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacientesInclude<ExtArgs> | null
    where?: pacientesWhereInput
    orderBy?: pacientesOrderByWithRelationInput | pacientesOrderByWithRelationInput[]
    cursor?: pacientesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PacientesScalarFieldEnum | PacientesScalarFieldEnum[]
  }

  /**
   * tipo_documentos without action
   */
  export type tipo_documentosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_documentos
     */
    select?: tipo_documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipo_documentos
     */
    omit?: tipo_documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipo_documentosInclude<ExtArgs> | null
  }


  /**
   * Model citas
   */

  export type AggregateCitas = {
    _count: CitasCountAggregateOutputType | null
    _avg: CitasAvgAggregateOutputType | null
    _sum: CitasSumAggregateOutputType | null
    _min: CitasMinAggregateOutputType | null
    _max: CitasMaxAggregateOutputType | null
  }

  export type CitasAvgAggregateOutputType = {
    id_cita: number | null
    id_paciente: number | null
    id_medico: number | null
  }

  export type CitasSumAggregateOutputType = {
    id_cita: number | null
    id_paciente: number | null
    id_medico: number | null
  }

  export type CitasMinAggregateOutputType = {
    id_cita: number | null
    id_paciente: number | null
    id_medico: number | null
    fecha: Date | null
    hora: Date | null
    estado_cita: string | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_actualizacion: Date | null
  }

  export type CitasMaxAggregateOutputType = {
    id_cita: number | null
    id_paciente: number | null
    id_medico: number | null
    fecha: Date | null
    hora: Date | null
    estado_cita: string | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_actualizacion: Date | null
  }

  export type CitasCountAggregateOutputType = {
    id_cita: number
    id_paciente: number
    id_medico: number
    fecha: number
    hora: number
    estado_cita: number
    estado_auditoria: number
    fecha_creacion: number
    fecha_actualizacion: number
    _all: number
  }


  export type CitasAvgAggregateInputType = {
    id_cita?: true
    id_paciente?: true
    id_medico?: true
  }

  export type CitasSumAggregateInputType = {
    id_cita?: true
    id_paciente?: true
    id_medico?: true
  }

  export type CitasMinAggregateInputType = {
    id_cita?: true
    id_paciente?: true
    id_medico?: true
    fecha?: true
    hora?: true
    estado_cita?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_actualizacion?: true
  }

  export type CitasMaxAggregateInputType = {
    id_cita?: true
    id_paciente?: true
    id_medico?: true
    fecha?: true
    hora?: true
    estado_cita?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_actualizacion?: true
  }

  export type CitasCountAggregateInputType = {
    id_cita?: true
    id_paciente?: true
    id_medico?: true
    fecha?: true
    hora?: true
    estado_cita?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_actualizacion?: true
    _all?: true
  }

  export type CitasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which citas to aggregate.
     */
    where?: citasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of citas to fetch.
     */
    orderBy?: citasOrderByWithRelationInput | citasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: citasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` citas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` citas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned citas
    **/
    _count?: true | CitasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CitasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CitasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CitasMaxAggregateInputType
  }

  export type GetCitasAggregateType<T extends CitasAggregateArgs> = {
        [P in keyof T & keyof AggregateCitas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCitas[P]>
      : GetScalarType<T[P], AggregateCitas[P]>
  }




  export type citasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: citasWhereInput
    orderBy?: citasOrderByWithAggregationInput | citasOrderByWithAggregationInput[]
    by: CitasScalarFieldEnum[] | CitasScalarFieldEnum
    having?: citasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CitasCountAggregateInputType | true
    _avg?: CitasAvgAggregateInputType
    _sum?: CitasSumAggregateInputType
    _min?: CitasMinAggregateInputType
    _max?: CitasMaxAggregateInputType
  }

  export type CitasGroupByOutputType = {
    id_cita: number
    id_paciente: number
    id_medico: number
    fecha: Date
    hora: Date
    estado_cita: string | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_actualizacion: Date | null
    _count: CitasCountAggregateOutputType | null
    _avg: CitasAvgAggregateOutputType | null
    _sum: CitasSumAggregateOutputType | null
    _min: CitasMinAggregateOutputType | null
    _max: CitasMaxAggregateOutputType | null
  }

  type GetCitasGroupByPayload<T extends citasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CitasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CitasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CitasGroupByOutputType[P]>
            : GetScalarType<T[P], CitasGroupByOutputType[P]>
        }
      >
    >


  export type citasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_cita?: boolean
    id_paciente?: boolean
    id_medico?: boolean
    fecha?: boolean
    hora?: boolean
    estado_cita?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_actualizacion?: boolean
    medicos?: boolean | medicosDefaultArgs<ExtArgs>
    pacientes?: boolean | pacientesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["citas"]>

  export type citasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_cita?: boolean
    id_paciente?: boolean
    id_medico?: boolean
    fecha?: boolean
    hora?: boolean
    estado_cita?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_actualizacion?: boolean
    medicos?: boolean | medicosDefaultArgs<ExtArgs>
    pacientes?: boolean | pacientesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["citas"]>

  export type citasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_cita?: boolean
    id_paciente?: boolean
    id_medico?: boolean
    fecha?: boolean
    hora?: boolean
    estado_cita?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_actualizacion?: boolean
    medicos?: boolean | medicosDefaultArgs<ExtArgs>
    pacientes?: boolean | pacientesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["citas"]>

  export type citasSelectScalar = {
    id_cita?: boolean
    id_paciente?: boolean
    id_medico?: boolean
    fecha?: boolean
    hora?: boolean
    estado_cita?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_actualizacion?: boolean
  }

  export type citasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_cita" | "id_paciente" | "id_medico" | "fecha" | "hora" | "estado_cita" | "estado_auditoria" | "fecha_creacion" | "fecha_actualizacion", ExtArgs["result"]["citas"]>
  export type citasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicos?: boolean | medicosDefaultArgs<ExtArgs>
    pacientes?: boolean | pacientesDefaultArgs<ExtArgs>
  }
  export type citasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicos?: boolean | medicosDefaultArgs<ExtArgs>
    pacientes?: boolean | pacientesDefaultArgs<ExtArgs>
  }
  export type citasIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicos?: boolean | medicosDefaultArgs<ExtArgs>
    pacientes?: boolean | pacientesDefaultArgs<ExtArgs>
  }

  export type $citasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "citas"
    objects: {
      medicos: Prisma.$medicosPayload<ExtArgs>
      pacientes: Prisma.$pacientesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_cita: number
      id_paciente: number
      id_medico: number
      fecha: Date
      hora: Date
      estado_cita: string | null
      estado_auditoria: string | null
      fecha_creacion: Date | null
      fecha_actualizacion: Date | null
    }, ExtArgs["result"]["citas"]>
    composites: {}
  }

  type citasGetPayload<S extends boolean | null | undefined | citasDefaultArgs> = $Result.GetResult<Prisma.$citasPayload, S>

  type citasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<citasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CitasCountAggregateInputType | true
    }

  export interface citasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['citas'], meta: { name: 'citas' } }
    /**
     * Find zero or one Citas that matches the filter.
     * @param {citasFindUniqueArgs} args - Arguments to find a Citas
     * @example
     * // Get one Citas
     * const citas = await prisma.citas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends citasFindUniqueArgs>(args: SelectSubset<T, citasFindUniqueArgs<ExtArgs>>): Prisma__citasClient<$Result.GetResult<Prisma.$citasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Citas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {citasFindUniqueOrThrowArgs} args - Arguments to find a Citas
     * @example
     * // Get one Citas
     * const citas = await prisma.citas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends citasFindUniqueOrThrowArgs>(args: SelectSubset<T, citasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__citasClient<$Result.GetResult<Prisma.$citasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Citas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citasFindFirstArgs} args - Arguments to find a Citas
     * @example
     * // Get one Citas
     * const citas = await prisma.citas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends citasFindFirstArgs>(args?: SelectSubset<T, citasFindFirstArgs<ExtArgs>>): Prisma__citasClient<$Result.GetResult<Prisma.$citasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Citas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citasFindFirstOrThrowArgs} args - Arguments to find a Citas
     * @example
     * // Get one Citas
     * const citas = await prisma.citas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends citasFindFirstOrThrowArgs>(args?: SelectSubset<T, citasFindFirstOrThrowArgs<ExtArgs>>): Prisma__citasClient<$Result.GetResult<Prisma.$citasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Citas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Citas
     * const citas = await prisma.citas.findMany()
     * 
     * // Get first 10 Citas
     * const citas = await prisma.citas.findMany({ take: 10 })
     * 
     * // Only select the `id_cita`
     * const citasWithId_citaOnly = await prisma.citas.findMany({ select: { id_cita: true } })
     * 
     */
    findMany<T extends citasFindManyArgs>(args?: SelectSubset<T, citasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$citasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Citas.
     * @param {citasCreateArgs} args - Arguments to create a Citas.
     * @example
     * // Create one Citas
     * const Citas = await prisma.citas.create({
     *   data: {
     *     // ... data to create a Citas
     *   }
     * })
     * 
     */
    create<T extends citasCreateArgs>(args: SelectSubset<T, citasCreateArgs<ExtArgs>>): Prisma__citasClient<$Result.GetResult<Prisma.$citasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Citas.
     * @param {citasCreateManyArgs} args - Arguments to create many Citas.
     * @example
     * // Create many Citas
     * const citas = await prisma.citas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends citasCreateManyArgs>(args?: SelectSubset<T, citasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Citas and returns the data saved in the database.
     * @param {citasCreateManyAndReturnArgs} args - Arguments to create many Citas.
     * @example
     * // Create many Citas
     * const citas = await prisma.citas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Citas and only return the `id_cita`
     * const citasWithId_citaOnly = await prisma.citas.createManyAndReturn({
     *   select: { id_cita: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends citasCreateManyAndReturnArgs>(args?: SelectSubset<T, citasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$citasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Citas.
     * @param {citasDeleteArgs} args - Arguments to delete one Citas.
     * @example
     * // Delete one Citas
     * const Citas = await prisma.citas.delete({
     *   where: {
     *     // ... filter to delete one Citas
     *   }
     * })
     * 
     */
    delete<T extends citasDeleteArgs>(args: SelectSubset<T, citasDeleteArgs<ExtArgs>>): Prisma__citasClient<$Result.GetResult<Prisma.$citasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Citas.
     * @param {citasUpdateArgs} args - Arguments to update one Citas.
     * @example
     * // Update one Citas
     * const citas = await prisma.citas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends citasUpdateArgs>(args: SelectSubset<T, citasUpdateArgs<ExtArgs>>): Prisma__citasClient<$Result.GetResult<Prisma.$citasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Citas.
     * @param {citasDeleteManyArgs} args - Arguments to filter Citas to delete.
     * @example
     * // Delete a few Citas
     * const { count } = await prisma.citas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends citasDeleteManyArgs>(args?: SelectSubset<T, citasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Citas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Citas
     * const citas = await prisma.citas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends citasUpdateManyArgs>(args: SelectSubset<T, citasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Citas and returns the data updated in the database.
     * @param {citasUpdateManyAndReturnArgs} args - Arguments to update many Citas.
     * @example
     * // Update many Citas
     * const citas = await prisma.citas.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Citas and only return the `id_cita`
     * const citasWithId_citaOnly = await prisma.citas.updateManyAndReturn({
     *   select: { id_cita: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends citasUpdateManyAndReturnArgs>(args: SelectSubset<T, citasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$citasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Citas.
     * @param {citasUpsertArgs} args - Arguments to update or create a Citas.
     * @example
     * // Update or create a Citas
     * const citas = await prisma.citas.upsert({
     *   create: {
     *     // ... data to create a Citas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Citas we want to update
     *   }
     * })
     */
    upsert<T extends citasUpsertArgs>(args: SelectSubset<T, citasUpsertArgs<ExtArgs>>): Prisma__citasClient<$Result.GetResult<Prisma.$citasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Citas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citasCountArgs} args - Arguments to filter Citas to count.
     * @example
     * // Count the number of Citas
     * const count = await prisma.citas.count({
     *   where: {
     *     // ... the filter for the Citas we want to count
     *   }
     * })
    **/
    count<T extends citasCountArgs>(
      args?: Subset<T, citasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CitasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Citas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CitasAggregateArgs>(args: Subset<T, CitasAggregateArgs>): Prisma.PrismaPromise<GetCitasAggregateType<T>>

    /**
     * Group by Citas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends citasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: citasGroupByArgs['orderBy'] }
        : { orderBy?: citasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, citasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCitasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the citas model
   */
  readonly fields: citasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for citas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__citasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicos<T extends medicosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, medicosDefaultArgs<ExtArgs>>): Prisma__medicosClient<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pacientes<T extends pacientesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pacientesDefaultArgs<ExtArgs>>): Prisma__pacientesClient<$Result.GetResult<Prisma.$pacientesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the citas model
   */
  interface citasFieldRefs {
    readonly id_cita: FieldRef<"citas", 'Int'>
    readonly id_paciente: FieldRef<"citas", 'Int'>
    readonly id_medico: FieldRef<"citas", 'Int'>
    readonly fecha: FieldRef<"citas", 'DateTime'>
    readonly hora: FieldRef<"citas", 'DateTime'>
    readonly estado_cita: FieldRef<"citas", 'String'>
    readonly estado_auditoria: FieldRef<"citas", 'String'>
    readonly fecha_creacion: FieldRef<"citas", 'DateTime'>
    readonly fecha_actualizacion: FieldRef<"citas", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * citas findUnique
   */
  export type citasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the citas
     */
    select?: citasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the citas
     */
    omit?: citasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citasInclude<ExtArgs> | null
    /**
     * Filter, which citas to fetch.
     */
    where: citasWhereUniqueInput
  }

  /**
   * citas findUniqueOrThrow
   */
  export type citasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the citas
     */
    select?: citasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the citas
     */
    omit?: citasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citasInclude<ExtArgs> | null
    /**
     * Filter, which citas to fetch.
     */
    where: citasWhereUniqueInput
  }

  /**
   * citas findFirst
   */
  export type citasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the citas
     */
    select?: citasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the citas
     */
    omit?: citasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citasInclude<ExtArgs> | null
    /**
     * Filter, which citas to fetch.
     */
    where?: citasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of citas to fetch.
     */
    orderBy?: citasOrderByWithRelationInput | citasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for citas.
     */
    cursor?: citasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` citas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` citas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of citas.
     */
    distinct?: CitasScalarFieldEnum | CitasScalarFieldEnum[]
  }

  /**
   * citas findFirstOrThrow
   */
  export type citasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the citas
     */
    select?: citasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the citas
     */
    omit?: citasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citasInclude<ExtArgs> | null
    /**
     * Filter, which citas to fetch.
     */
    where?: citasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of citas to fetch.
     */
    orderBy?: citasOrderByWithRelationInput | citasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for citas.
     */
    cursor?: citasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` citas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` citas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of citas.
     */
    distinct?: CitasScalarFieldEnum | CitasScalarFieldEnum[]
  }

  /**
   * citas findMany
   */
  export type citasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the citas
     */
    select?: citasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the citas
     */
    omit?: citasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citasInclude<ExtArgs> | null
    /**
     * Filter, which citas to fetch.
     */
    where?: citasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of citas to fetch.
     */
    orderBy?: citasOrderByWithRelationInput | citasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing citas.
     */
    cursor?: citasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` citas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` citas.
     */
    skip?: number
    distinct?: CitasScalarFieldEnum | CitasScalarFieldEnum[]
  }

  /**
   * citas create
   */
  export type citasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the citas
     */
    select?: citasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the citas
     */
    omit?: citasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citasInclude<ExtArgs> | null
    /**
     * The data needed to create a citas.
     */
    data: XOR<citasCreateInput, citasUncheckedCreateInput>
  }

  /**
   * citas createMany
   */
  export type citasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many citas.
     */
    data: citasCreateManyInput | citasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * citas createManyAndReturn
   */
  export type citasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the citas
     */
    select?: citasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the citas
     */
    omit?: citasOmit<ExtArgs> | null
    /**
     * The data used to create many citas.
     */
    data: citasCreateManyInput | citasCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citasIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * citas update
   */
  export type citasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the citas
     */
    select?: citasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the citas
     */
    omit?: citasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citasInclude<ExtArgs> | null
    /**
     * The data needed to update a citas.
     */
    data: XOR<citasUpdateInput, citasUncheckedUpdateInput>
    /**
     * Choose, which citas to update.
     */
    where: citasWhereUniqueInput
  }

  /**
   * citas updateMany
   */
  export type citasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update citas.
     */
    data: XOR<citasUpdateManyMutationInput, citasUncheckedUpdateManyInput>
    /**
     * Filter which citas to update
     */
    where?: citasWhereInput
    /**
     * Limit how many citas to update.
     */
    limit?: number
  }

  /**
   * citas updateManyAndReturn
   */
  export type citasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the citas
     */
    select?: citasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the citas
     */
    omit?: citasOmit<ExtArgs> | null
    /**
     * The data used to update citas.
     */
    data: XOR<citasUpdateManyMutationInput, citasUncheckedUpdateManyInput>
    /**
     * Filter which citas to update
     */
    where?: citasWhereInput
    /**
     * Limit how many citas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citasIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * citas upsert
   */
  export type citasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the citas
     */
    select?: citasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the citas
     */
    omit?: citasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citasInclude<ExtArgs> | null
    /**
     * The filter to search for the citas to update in case it exists.
     */
    where: citasWhereUniqueInput
    /**
     * In case the citas found by the `where` argument doesn't exist, create a new citas with this data.
     */
    create: XOR<citasCreateInput, citasUncheckedCreateInput>
    /**
     * In case the citas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<citasUpdateInput, citasUncheckedUpdateInput>
  }

  /**
   * citas delete
   */
  export type citasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the citas
     */
    select?: citasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the citas
     */
    omit?: citasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citasInclude<ExtArgs> | null
    /**
     * Filter which citas to delete.
     */
    where: citasWhereUniqueInput
  }

  /**
   * citas deleteMany
   */
  export type citasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which citas to delete
     */
    where?: citasWhereInput
    /**
     * Limit how many citas to delete.
     */
    limit?: number
  }

  /**
   * citas without action
   */
  export type citasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the citas
     */
    select?: citasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the citas
     */
    omit?: citasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citasInclude<ExtArgs> | null
  }


  /**
   * Model especialidades
   */

  export type AggregateEspecialidades = {
    _count: EspecialidadesCountAggregateOutputType | null
    _avg: EspecialidadesAvgAggregateOutputType | null
    _sum: EspecialidadesSumAggregateOutputType | null
    _min: EspecialidadesMinAggregateOutputType | null
    _max: EspecialidadesMaxAggregateOutputType | null
  }

  export type EspecialidadesAvgAggregateOutputType = {
    id_especialidad: number | null
  }

  export type EspecialidadesSumAggregateOutputType = {
    id_especialidad: number | null
  }

  export type EspecialidadesMinAggregateOutputType = {
    id_especialidad: number | null
    nombre: string | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_actualizacion: Date | null
  }

  export type EspecialidadesMaxAggregateOutputType = {
    id_especialidad: number | null
    nombre: string | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_actualizacion: Date | null
  }

  export type EspecialidadesCountAggregateOutputType = {
    id_especialidad: number
    nombre: number
    estado_auditoria: number
    fecha_creacion: number
    fecha_actualizacion: number
    _all: number
  }


  export type EspecialidadesAvgAggregateInputType = {
    id_especialidad?: true
  }

  export type EspecialidadesSumAggregateInputType = {
    id_especialidad?: true
  }

  export type EspecialidadesMinAggregateInputType = {
    id_especialidad?: true
    nombre?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_actualizacion?: true
  }

  export type EspecialidadesMaxAggregateInputType = {
    id_especialidad?: true
    nombre?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_actualizacion?: true
  }

  export type EspecialidadesCountAggregateInputType = {
    id_especialidad?: true
    nombre?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_actualizacion?: true
    _all?: true
  }

  export type EspecialidadesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which especialidades to aggregate.
     */
    where?: especialidadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of especialidades to fetch.
     */
    orderBy?: especialidadesOrderByWithRelationInput | especialidadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: especialidadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` especialidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` especialidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned especialidades
    **/
    _count?: true | EspecialidadesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EspecialidadesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EspecialidadesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EspecialidadesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EspecialidadesMaxAggregateInputType
  }

  export type GetEspecialidadesAggregateType<T extends EspecialidadesAggregateArgs> = {
        [P in keyof T & keyof AggregateEspecialidades]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEspecialidades[P]>
      : GetScalarType<T[P], AggregateEspecialidades[P]>
  }




  export type especialidadesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: especialidadesWhereInput
    orderBy?: especialidadesOrderByWithAggregationInput | especialidadesOrderByWithAggregationInput[]
    by: EspecialidadesScalarFieldEnum[] | EspecialidadesScalarFieldEnum
    having?: especialidadesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EspecialidadesCountAggregateInputType | true
    _avg?: EspecialidadesAvgAggregateInputType
    _sum?: EspecialidadesSumAggregateInputType
    _min?: EspecialidadesMinAggregateInputType
    _max?: EspecialidadesMaxAggregateInputType
  }

  export type EspecialidadesGroupByOutputType = {
    id_especialidad: number
    nombre: string
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_actualizacion: Date | null
    _count: EspecialidadesCountAggregateOutputType | null
    _avg: EspecialidadesAvgAggregateOutputType | null
    _sum: EspecialidadesSumAggregateOutputType | null
    _min: EspecialidadesMinAggregateOutputType | null
    _max: EspecialidadesMaxAggregateOutputType | null
  }

  type GetEspecialidadesGroupByPayload<T extends especialidadesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EspecialidadesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EspecialidadesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EspecialidadesGroupByOutputType[P]>
            : GetScalarType<T[P], EspecialidadesGroupByOutputType[P]>
        }
      >
    >


  export type especialidadesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_especialidad?: boolean
    nombre?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_actualizacion?: boolean
    medicos?: boolean | especialidades$medicosArgs<ExtArgs>
    _count?: boolean | EspecialidadesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["especialidades"]>

  export type especialidadesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_especialidad?: boolean
    nombre?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_actualizacion?: boolean
  }, ExtArgs["result"]["especialidades"]>

  export type especialidadesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_especialidad?: boolean
    nombre?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_actualizacion?: boolean
  }, ExtArgs["result"]["especialidades"]>

  export type especialidadesSelectScalar = {
    id_especialidad?: boolean
    nombre?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_actualizacion?: boolean
  }

  export type especialidadesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_especialidad" | "nombre" | "estado_auditoria" | "fecha_creacion" | "fecha_actualizacion", ExtArgs["result"]["especialidades"]>
  export type especialidadesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicos?: boolean | especialidades$medicosArgs<ExtArgs>
    _count?: boolean | EspecialidadesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type especialidadesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type especialidadesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $especialidadesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "especialidades"
    objects: {
      medicos: Prisma.$medicosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_especialidad: number
      nombre: string
      estado_auditoria: string | null
      fecha_creacion: Date | null
      fecha_actualizacion: Date | null
    }, ExtArgs["result"]["especialidades"]>
    composites: {}
  }

  type especialidadesGetPayload<S extends boolean | null | undefined | especialidadesDefaultArgs> = $Result.GetResult<Prisma.$especialidadesPayload, S>

  type especialidadesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<especialidadesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EspecialidadesCountAggregateInputType | true
    }

  export interface especialidadesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['especialidades'], meta: { name: 'especialidades' } }
    /**
     * Find zero or one Especialidades that matches the filter.
     * @param {especialidadesFindUniqueArgs} args - Arguments to find a Especialidades
     * @example
     * // Get one Especialidades
     * const especialidades = await prisma.especialidades.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends especialidadesFindUniqueArgs>(args: SelectSubset<T, especialidadesFindUniqueArgs<ExtArgs>>): Prisma__especialidadesClient<$Result.GetResult<Prisma.$especialidadesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Especialidades that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {especialidadesFindUniqueOrThrowArgs} args - Arguments to find a Especialidades
     * @example
     * // Get one Especialidades
     * const especialidades = await prisma.especialidades.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends especialidadesFindUniqueOrThrowArgs>(args: SelectSubset<T, especialidadesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__especialidadesClient<$Result.GetResult<Prisma.$especialidadesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Especialidades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidadesFindFirstArgs} args - Arguments to find a Especialidades
     * @example
     * // Get one Especialidades
     * const especialidades = await prisma.especialidades.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends especialidadesFindFirstArgs>(args?: SelectSubset<T, especialidadesFindFirstArgs<ExtArgs>>): Prisma__especialidadesClient<$Result.GetResult<Prisma.$especialidadesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Especialidades that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidadesFindFirstOrThrowArgs} args - Arguments to find a Especialidades
     * @example
     * // Get one Especialidades
     * const especialidades = await prisma.especialidades.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends especialidadesFindFirstOrThrowArgs>(args?: SelectSubset<T, especialidadesFindFirstOrThrowArgs<ExtArgs>>): Prisma__especialidadesClient<$Result.GetResult<Prisma.$especialidadesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Especialidades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidadesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Especialidades
     * const especialidades = await prisma.especialidades.findMany()
     * 
     * // Get first 10 Especialidades
     * const especialidades = await prisma.especialidades.findMany({ take: 10 })
     * 
     * // Only select the `id_especialidad`
     * const especialidadesWithId_especialidadOnly = await prisma.especialidades.findMany({ select: { id_especialidad: true } })
     * 
     */
    findMany<T extends especialidadesFindManyArgs>(args?: SelectSubset<T, especialidadesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$especialidadesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Especialidades.
     * @param {especialidadesCreateArgs} args - Arguments to create a Especialidades.
     * @example
     * // Create one Especialidades
     * const Especialidades = await prisma.especialidades.create({
     *   data: {
     *     // ... data to create a Especialidades
     *   }
     * })
     * 
     */
    create<T extends especialidadesCreateArgs>(args: SelectSubset<T, especialidadesCreateArgs<ExtArgs>>): Prisma__especialidadesClient<$Result.GetResult<Prisma.$especialidadesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Especialidades.
     * @param {especialidadesCreateManyArgs} args - Arguments to create many Especialidades.
     * @example
     * // Create many Especialidades
     * const especialidades = await prisma.especialidades.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends especialidadesCreateManyArgs>(args?: SelectSubset<T, especialidadesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Especialidades and returns the data saved in the database.
     * @param {especialidadesCreateManyAndReturnArgs} args - Arguments to create many Especialidades.
     * @example
     * // Create many Especialidades
     * const especialidades = await prisma.especialidades.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Especialidades and only return the `id_especialidad`
     * const especialidadesWithId_especialidadOnly = await prisma.especialidades.createManyAndReturn({
     *   select: { id_especialidad: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends especialidadesCreateManyAndReturnArgs>(args?: SelectSubset<T, especialidadesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$especialidadesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Especialidades.
     * @param {especialidadesDeleteArgs} args - Arguments to delete one Especialidades.
     * @example
     * // Delete one Especialidades
     * const Especialidades = await prisma.especialidades.delete({
     *   where: {
     *     // ... filter to delete one Especialidades
     *   }
     * })
     * 
     */
    delete<T extends especialidadesDeleteArgs>(args: SelectSubset<T, especialidadesDeleteArgs<ExtArgs>>): Prisma__especialidadesClient<$Result.GetResult<Prisma.$especialidadesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Especialidades.
     * @param {especialidadesUpdateArgs} args - Arguments to update one Especialidades.
     * @example
     * // Update one Especialidades
     * const especialidades = await prisma.especialidades.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends especialidadesUpdateArgs>(args: SelectSubset<T, especialidadesUpdateArgs<ExtArgs>>): Prisma__especialidadesClient<$Result.GetResult<Prisma.$especialidadesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Especialidades.
     * @param {especialidadesDeleteManyArgs} args - Arguments to filter Especialidades to delete.
     * @example
     * // Delete a few Especialidades
     * const { count } = await prisma.especialidades.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends especialidadesDeleteManyArgs>(args?: SelectSubset<T, especialidadesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Especialidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidadesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Especialidades
     * const especialidades = await prisma.especialidades.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends especialidadesUpdateManyArgs>(args: SelectSubset<T, especialidadesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Especialidades and returns the data updated in the database.
     * @param {especialidadesUpdateManyAndReturnArgs} args - Arguments to update many Especialidades.
     * @example
     * // Update many Especialidades
     * const especialidades = await prisma.especialidades.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Especialidades and only return the `id_especialidad`
     * const especialidadesWithId_especialidadOnly = await prisma.especialidades.updateManyAndReturn({
     *   select: { id_especialidad: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends especialidadesUpdateManyAndReturnArgs>(args: SelectSubset<T, especialidadesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$especialidadesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Especialidades.
     * @param {especialidadesUpsertArgs} args - Arguments to update or create a Especialidades.
     * @example
     * // Update or create a Especialidades
     * const especialidades = await prisma.especialidades.upsert({
     *   create: {
     *     // ... data to create a Especialidades
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Especialidades we want to update
     *   }
     * })
     */
    upsert<T extends especialidadesUpsertArgs>(args: SelectSubset<T, especialidadesUpsertArgs<ExtArgs>>): Prisma__especialidadesClient<$Result.GetResult<Prisma.$especialidadesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Especialidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidadesCountArgs} args - Arguments to filter Especialidades to count.
     * @example
     * // Count the number of Especialidades
     * const count = await prisma.especialidades.count({
     *   where: {
     *     // ... the filter for the Especialidades we want to count
     *   }
     * })
    **/
    count<T extends especialidadesCountArgs>(
      args?: Subset<T, especialidadesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EspecialidadesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Especialidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecialidadesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EspecialidadesAggregateArgs>(args: Subset<T, EspecialidadesAggregateArgs>): Prisma.PrismaPromise<GetEspecialidadesAggregateType<T>>

    /**
     * Group by Especialidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidadesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends especialidadesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: especialidadesGroupByArgs['orderBy'] }
        : { orderBy?: especialidadesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, especialidadesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEspecialidadesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the especialidades model
   */
  readonly fields: especialidadesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for especialidades.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__especialidadesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicos<T extends especialidades$medicosArgs<ExtArgs> = {}>(args?: Subset<T, especialidades$medicosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the especialidades model
   */
  interface especialidadesFieldRefs {
    readonly id_especialidad: FieldRef<"especialidades", 'Int'>
    readonly nombre: FieldRef<"especialidades", 'String'>
    readonly estado_auditoria: FieldRef<"especialidades", 'String'>
    readonly fecha_creacion: FieldRef<"especialidades", 'DateTime'>
    readonly fecha_actualizacion: FieldRef<"especialidades", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * especialidades findUnique
   */
  export type especialidadesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidades
     */
    select?: especialidadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidades
     */
    omit?: especialidadesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadesInclude<ExtArgs> | null
    /**
     * Filter, which especialidades to fetch.
     */
    where: especialidadesWhereUniqueInput
  }

  /**
   * especialidades findUniqueOrThrow
   */
  export type especialidadesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidades
     */
    select?: especialidadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidades
     */
    omit?: especialidadesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadesInclude<ExtArgs> | null
    /**
     * Filter, which especialidades to fetch.
     */
    where: especialidadesWhereUniqueInput
  }

  /**
   * especialidades findFirst
   */
  export type especialidadesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidades
     */
    select?: especialidadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidades
     */
    omit?: especialidadesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadesInclude<ExtArgs> | null
    /**
     * Filter, which especialidades to fetch.
     */
    where?: especialidadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of especialidades to fetch.
     */
    orderBy?: especialidadesOrderByWithRelationInput | especialidadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for especialidades.
     */
    cursor?: especialidadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` especialidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` especialidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of especialidades.
     */
    distinct?: EspecialidadesScalarFieldEnum | EspecialidadesScalarFieldEnum[]
  }

  /**
   * especialidades findFirstOrThrow
   */
  export type especialidadesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidades
     */
    select?: especialidadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidades
     */
    omit?: especialidadesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadesInclude<ExtArgs> | null
    /**
     * Filter, which especialidades to fetch.
     */
    where?: especialidadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of especialidades to fetch.
     */
    orderBy?: especialidadesOrderByWithRelationInput | especialidadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for especialidades.
     */
    cursor?: especialidadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` especialidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` especialidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of especialidades.
     */
    distinct?: EspecialidadesScalarFieldEnum | EspecialidadesScalarFieldEnum[]
  }

  /**
   * especialidades findMany
   */
  export type especialidadesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidades
     */
    select?: especialidadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidades
     */
    omit?: especialidadesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadesInclude<ExtArgs> | null
    /**
     * Filter, which especialidades to fetch.
     */
    where?: especialidadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of especialidades to fetch.
     */
    orderBy?: especialidadesOrderByWithRelationInput | especialidadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing especialidades.
     */
    cursor?: especialidadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` especialidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` especialidades.
     */
    skip?: number
    distinct?: EspecialidadesScalarFieldEnum | EspecialidadesScalarFieldEnum[]
  }

  /**
   * especialidades create
   */
  export type especialidadesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidades
     */
    select?: especialidadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidades
     */
    omit?: especialidadesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadesInclude<ExtArgs> | null
    /**
     * The data needed to create a especialidades.
     */
    data: XOR<especialidadesCreateInput, especialidadesUncheckedCreateInput>
  }

  /**
   * especialidades createMany
   */
  export type especialidadesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many especialidades.
     */
    data: especialidadesCreateManyInput | especialidadesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * especialidades createManyAndReturn
   */
  export type especialidadesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidades
     */
    select?: especialidadesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the especialidades
     */
    omit?: especialidadesOmit<ExtArgs> | null
    /**
     * The data used to create many especialidades.
     */
    data: especialidadesCreateManyInput | especialidadesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * especialidades update
   */
  export type especialidadesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidades
     */
    select?: especialidadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidades
     */
    omit?: especialidadesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadesInclude<ExtArgs> | null
    /**
     * The data needed to update a especialidades.
     */
    data: XOR<especialidadesUpdateInput, especialidadesUncheckedUpdateInput>
    /**
     * Choose, which especialidades to update.
     */
    where: especialidadesWhereUniqueInput
  }

  /**
   * especialidades updateMany
   */
  export type especialidadesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update especialidades.
     */
    data: XOR<especialidadesUpdateManyMutationInput, especialidadesUncheckedUpdateManyInput>
    /**
     * Filter which especialidades to update
     */
    where?: especialidadesWhereInput
    /**
     * Limit how many especialidades to update.
     */
    limit?: number
  }

  /**
   * especialidades updateManyAndReturn
   */
  export type especialidadesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidades
     */
    select?: especialidadesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the especialidades
     */
    omit?: especialidadesOmit<ExtArgs> | null
    /**
     * The data used to update especialidades.
     */
    data: XOR<especialidadesUpdateManyMutationInput, especialidadesUncheckedUpdateManyInput>
    /**
     * Filter which especialidades to update
     */
    where?: especialidadesWhereInput
    /**
     * Limit how many especialidades to update.
     */
    limit?: number
  }

  /**
   * especialidades upsert
   */
  export type especialidadesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidades
     */
    select?: especialidadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidades
     */
    omit?: especialidadesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadesInclude<ExtArgs> | null
    /**
     * The filter to search for the especialidades to update in case it exists.
     */
    where: especialidadesWhereUniqueInput
    /**
     * In case the especialidades found by the `where` argument doesn't exist, create a new especialidades with this data.
     */
    create: XOR<especialidadesCreateInput, especialidadesUncheckedCreateInput>
    /**
     * In case the especialidades was found with the provided `where` argument, update it with this data.
     */
    update: XOR<especialidadesUpdateInput, especialidadesUncheckedUpdateInput>
  }

  /**
   * especialidades delete
   */
  export type especialidadesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidades
     */
    select?: especialidadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidades
     */
    omit?: especialidadesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadesInclude<ExtArgs> | null
    /**
     * Filter which especialidades to delete.
     */
    where: especialidadesWhereUniqueInput
  }

  /**
   * especialidades deleteMany
   */
  export type especialidadesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which especialidades to delete
     */
    where?: especialidadesWhereInput
    /**
     * Limit how many especialidades to delete.
     */
    limit?: number
  }

  /**
   * especialidades.medicos
   */
  export type especialidades$medicosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicos
     */
    select?: medicosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicos
     */
    omit?: medicosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicosInclude<ExtArgs> | null
    where?: medicosWhereInput
    orderBy?: medicosOrderByWithRelationInput | medicosOrderByWithRelationInput[]
    cursor?: medicosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicosScalarFieldEnum | MedicosScalarFieldEnum[]
  }

  /**
   * especialidades without action
   */
  export type especialidadesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidades
     */
    select?: especialidadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especialidades
     */
    omit?: especialidadesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadesInclude<ExtArgs> | null
  }


  /**
   * Model horarios
   */

  export type AggregateHorarios = {
    _count: HorariosCountAggregateOutputType | null
    _avg: HorariosAvgAggregateOutputType | null
    _sum: HorariosSumAggregateOutputType | null
    _min: HorariosMinAggregateOutputType | null
    _max: HorariosMaxAggregateOutputType | null
  }

  export type HorariosAvgAggregateOutputType = {
    id_horario: number | null
    id_medico: number | null
  }

  export type HorariosSumAggregateOutputType = {
    id_horario: number | null
    id_medico: number | null
  }

  export type HorariosMinAggregateOutputType = {
    id_horario: number | null
    id_medico: number | null
    dia_semana: string | null
    hora_inicio: Date | null
    hora_fin: Date | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_actualizacion: Date | null
  }

  export type HorariosMaxAggregateOutputType = {
    id_horario: number | null
    id_medico: number | null
    dia_semana: string | null
    hora_inicio: Date | null
    hora_fin: Date | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_actualizacion: Date | null
  }

  export type HorariosCountAggregateOutputType = {
    id_horario: number
    id_medico: number
    dia_semana: number
    hora_inicio: number
    hora_fin: number
    estado_auditoria: number
    fecha_creacion: number
    fecha_actualizacion: number
    _all: number
  }


  export type HorariosAvgAggregateInputType = {
    id_horario?: true
    id_medico?: true
  }

  export type HorariosSumAggregateInputType = {
    id_horario?: true
    id_medico?: true
  }

  export type HorariosMinAggregateInputType = {
    id_horario?: true
    id_medico?: true
    dia_semana?: true
    hora_inicio?: true
    hora_fin?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_actualizacion?: true
  }

  export type HorariosMaxAggregateInputType = {
    id_horario?: true
    id_medico?: true
    dia_semana?: true
    hora_inicio?: true
    hora_fin?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_actualizacion?: true
  }

  export type HorariosCountAggregateInputType = {
    id_horario?: true
    id_medico?: true
    dia_semana?: true
    hora_inicio?: true
    hora_fin?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_actualizacion?: true
    _all?: true
  }

  export type HorariosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which horarios to aggregate.
     */
    where?: horariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of horarios to fetch.
     */
    orderBy?: horariosOrderByWithRelationInput | horariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: horariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` horarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` horarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned horarios
    **/
    _count?: true | HorariosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HorariosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HorariosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HorariosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HorariosMaxAggregateInputType
  }

  export type GetHorariosAggregateType<T extends HorariosAggregateArgs> = {
        [P in keyof T & keyof AggregateHorarios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHorarios[P]>
      : GetScalarType<T[P], AggregateHorarios[P]>
  }




  export type horariosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: horariosWhereInput
    orderBy?: horariosOrderByWithAggregationInput | horariosOrderByWithAggregationInput[]
    by: HorariosScalarFieldEnum[] | HorariosScalarFieldEnum
    having?: horariosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HorariosCountAggregateInputType | true
    _avg?: HorariosAvgAggregateInputType
    _sum?: HorariosSumAggregateInputType
    _min?: HorariosMinAggregateInputType
    _max?: HorariosMaxAggregateInputType
  }

  export type HorariosGroupByOutputType = {
    id_horario: number
    id_medico: number
    dia_semana: string
    hora_inicio: Date
    hora_fin: Date
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_actualizacion: Date | null
    _count: HorariosCountAggregateOutputType | null
    _avg: HorariosAvgAggregateOutputType | null
    _sum: HorariosSumAggregateOutputType | null
    _min: HorariosMinAggregateOutputType | null
    _max: HorariosMaxAggregateOutputType | null
  }

  type GetHorariosGroupByPayload<T extends horariosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HorariosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HorariosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HorariosGroupByOutputType[P]>
            : GetScalarType<T[P], HorariosGroupByOutputType[P]>
        }
      >
    >


  export type horariosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_horario?: boolean
    id_medico?: boolean
    dia_semana?: boolean
    hora_inicio?: boolean
    hora_fin?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_actualizacion?: boolean
    medicos?: boolean | medicosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["horarios"]>

  export type horariosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_horario?: boolean
    id_medico?: boolean
    dia_semana?: boolean
    hora_inicio?: boolean
    hora_fin?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_actualizacion?: boolean
    medicos?: boolean | medicosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["horarios"]>

  export type horariosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_horario?: boolean
    id_medico?: boolean
    dia_semana?: boolean
    hora_inicio?: boolean
    hora_fin?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_actualizacion?: boolean
    medicos?: boolean | medicosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["horarios"]>

  export type horariosSelectScalar = {
    id_horario?: boolean
    id_medico?: boolean
    dia_semana?: boolean
    hora_inicio?: boolean
    hora_fin?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_actualizacion?: boolean
  }

  export type horariosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_horario" | "id_medico" | "dia_semana" | "hora_inicio" | "hora_fin" | "estado_auditoria" | "fecha_creacion" | "fecha_actualizacion", ExtArgs["result"]["horarios"]>
  export type horariosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicos?: boolean | medicosDefaultArgs<ExtArgs>
  }
  export type horariosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicos?: boolean | medicosDefaultArgs<ExtArgs>
  }
  export type horariosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicos?: boolean | medicosDefaultArgs<ExtArgs>
  }

  export type $horariosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "horarios"
    objects: {
      medicos: Prisma.$medicosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_horario: number
      id_medico: number
      dia_semana: string
      hora_inicio: Date
      hora_fin: Date
      estado_auditoria: string | null
      fecha_creacion: Date | null
      fecha_actualizacion: Date | null
    }, ExtArgs["result"]["horarios"]>
    composites: {}
  }

  type horariosGetPayload<S extends boolean | null | undefined | horariosDefaultArgs> = $Result.GetResult<Prisma.$horariosPayload, S>

  type horariosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<horariosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HorariosCountAggregateInputType | true
    }

  export interface horariosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['horarios'], meta: { name: 'horarios' } }
    /**
     * Find zero or one Horarios that matches the filter.
     * @param {horariosFindUniqueArgs} args - Arguments to find a Horarios
     * @example
     * // Get one Horarios
     * const horarios = await prisma.horarios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends horariosFindUniqueArgs>(args: SelectSubset<T, horariosFindUniqueArgs<ExtArgs>>): Prisma__horariosClient<$Result.GetResult<Prisma.$horariosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Horarios that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {horariosFindUniqueOrThrowArgs} args - Arguments to find a Horarios
     * @example
     * // Get one Horarios
     * const horarios = await prisma.horarios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends horariosFindUniqueOrThrowArgs>(args: SelectSubset<T, horariosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__horariosClient<$Result.GetResult<Prisma.$horariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Horarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {horariosFindFirstArgs} args - Arguments to find a Horarios
     * @example
     * // Get one Horarios
     * const horarios = await prisma.horarios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends horariosFindFirstArgs>(args?: SelectSubset<T, horariosFindFirstArgs<ExtArgs>>): Prisma__horariosClient<$Result.GetResult<Prisma.$horariosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Horarios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {horariosFindFirstOrThrowArgs} args - Arguments to find a Horarios
     * @example
     * // Get one Horarios
     * const horarios = await prisma.horarios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends horariosFindFirstOrThrowArgs>(args?: SelectSubset<T, horariosFindFirstOrThrowArgs<ExtArgs>>): Prisma__horariosClient<$Result.GetResult<Prisma.$horariosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Horarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {horariosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Horarios
     * const horarios = await prisma.horarios.findMany()
     * 
     * // Get first 10 Horarios
     * const horarios = await prisma.horarios.findMany({ take: 10 })
     * 
     * // Only select the `id_horario`
     * const horariosWithId_horarioOnly = await prisma.horarios.findMany({ select: { id_horario: true } })
     * 
     */
    findMany<T extends horariosFindManyArgs>(args?: SelectSubset<T, horariosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$horariosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Horarios.
     * @param {horariosCreateArgs} args - Arguments to create a Horarios.
     * @example
     * // Create one Horarios
     * const Horarios = await prisma.horarios.create({
     *   data: {
     *     // ... data to create a Horarios
     *   }
     * })
     * 
     */
    create<T extends horariosCreateArgs>(args: SelectSubset<T, horariosCreateArgs<ExtArgs>>): Prisma__horariosClient<$Result.GetResult<Prisma.$horariosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Horarios.
     * @param {horariosCreateManyArgs} args - Arguments to create many Horarios.
     * @example
     * // Create many Horarios
     * const horarios = await prisma.horarios.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends horariosCreateManyArgs>(args?: SelectSubset<T, horariosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Horarios and returns the data saved in the database.
     * @param {horariosCreateManyAndReturnArgs} args - Arguments to create many Horarios.
     * @example
     * // Create many Horarios
     * const horarios = await prisma.horarios.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Horarios and only return the `id_horario`
     * const horariosWithId_horarioOnly = await prisma.horarios.createManyAndReturn({
     *   select: { id_horario: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends horariosCreateManyAndReturnArgs>(args?: SelectSubset<T, horariosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$horariosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Horarios.
     * @param {horariosDeleteArgs} args - Arguments to delete one Horarios.
     * @example
     * // Delete one Horarios
     * const Horarios = await prisma.horarios.delete({
     *   where: {
     *     // ... filter to delete one Horarios
     *   }
     * })
     * 
     */
    delete<T extends horariosDeleteArgs>(args: SelectSubset<T, horariosDeleteArgs<ExtArgs>>): Prisma__horariosClient<$Result.GetResult<Prisma.$horariosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Horarios.
     * @param {horariosUpdateArgs} args - Arguments to update one Horarios.
     * @example
     * // Update one Horarios
     * const horarios = await prisma.horarios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends horariosUpdateArgs>(args: SelectSubset<T, horariosUpdateArgs<ExtArgs>>): Prisma__horariosClient<$Result.GetResult<Prisma.$horariosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Horarios.
     * @param {horariosDeleteManyArgs} args - Arguments to filter Horarios to delete.
     * @example
     * // Delete a few Horarios
     * const { count } = await prisma.horarios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends horariosDeleteManyArgs>(args?: SelectSubset<T, horariosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Horarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {horariosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Horarios
     * const horarios = await prisma.horarios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends horariosUpdateManyArgs>(args: SelectSubset<T, horariosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Horarios and returns the data updated in the database.
     * @param {horariosUpdateManyAndReturnArgs} args - Arguments to update many Horarios.
     * @example
     * // Update many Horarios
     * const horarios = await prisma.horarios.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Horarios and only return the `id_horario`
     * const horariosWithId_horarioOnly = await prisma.horarios.updateManyAndReturn({
     *   select: { id_horario: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends horariosUpdateManyAndReturnArgs>(args: SelectSubset<T, horariosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$horariosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Horarios.
     * @param {horariosUpsertArgs} args - Arguments to update or create a Horarios.
     * @example
     * // Update or create a Horarios
     * const horarios = await prisma.horarios.upsert({
     *   create: {
     *     // ... data to create a Horarios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Horarios we want to update
     *   }
     * })
     */
    upsert<T extends horariosUpsertArgs>(args: SelectSubset<T, horariosUpsertArgs<ExtArgs>>): Prisma__horariosClient<$Result.GetResult<Prisma.$horariosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Horarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {horariosCountArgs} args - Arguments to filter Horarios to count.
     * @example
     * // Count the number of Horarios
     * const count = await prisma.horarios.count({
     *   where: {
     *     // ... the filter for the Horarios we want to count
     *   }
     * })
    **/
    count<T extends horariosCountArgs>(
      args?: Subset<T, horariosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HorariosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Horarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorariosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HorariosAggregateArgs>(args: Subset<T, HorariosAggregateArgs>): Prisma.PrismaPromise<GetHorariosAggregateType<T>>

    /**
     * Group by Horarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {horariosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends horariosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: horariosGroupByArgs['orderBy'] }
        : { orderBy?: horariosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, horariosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHorariosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the horarios model
   */
  readonly fields: horariosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for horarios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__horariosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicos<T extends medicosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, medicosDefaultArgs<ExtArgs>>): Prisma__medicosClient<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the horarios model
   */
  interface horariosFieldRefs {
    readonly id_horario: FieldRef<"horarios", 'Int'>
    readonly id_medico: FieldRef<"horarios", 'Int'>
    readonly dia_semana: FieldRef<"horarios", 'String'>
    readonly hora_inicio: FieldRef<"horarios", 'DateTime'>
    readonly hora_fin: FieldRef<"horarios", 'DateTime'>
    readonly estado_auditoria: FieldRef<"horarios", 'String'>
    readonly fecha_creacion: FieldRef<"horarios", 'DateTime'>
    readonly fecha_actualizacion: FieldRef<"horarios", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * horarios findUnique
   */
  export type horariosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horarios
     */
    select?: horariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horarios
     */
    omit?: horariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horariosInclude<ExtArgs> | null
    /**
     * Filter, which horarios to fetch.
     */
    where: horariosWhereUniqueInput
  }

  /**
   * horarios findUniqueOrThrow
   */
  export type horariosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horarios
     */
    select?: horariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horarios
     */
    omit?: horariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horariosInclude<ExtArgs> | null
    /**
     * Filter, which horarios to fetch.
     */
    where: horariosWhereUniqueInput
  }

  /**
   * horarios findFirst
   */
  export type horariosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horarios
     */
    select?: horariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horarios
     */
    omit?: horariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horariosInclude<ExtArgs> | null
    /**
     * Filter, which horarios to fetch.
     */
    where?: horariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of horarios to fetch.
     */
    orderBy?: horariosOrderByWithRelationInput | horariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for horarios.
     */
    cursor?: horariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` horarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` horarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of horarios.
     */
    distinct?: HorariosScalarFieldEnum | HorariosScalarFieldEnum[]
  }

  /**
   * horarios findFirstOrThrow
   */
  export type horariosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horarios
     */
    select?: horariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horarios
     */
    omit?: horariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horariosInclude<ExtArgs> | null
    /**
     * Filter, which horarios to fetch.
     */
    where?: horariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of horarios to fetch.
     */
    orderBy?: horariosOrderByWithRelationInput | horariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for horarios.
     */
    cursor?: horariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` horarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` horarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of horarios.
     */
    distinct?: HorariosScalarFieldEnum | HorariosScalarFieldEnum[]
  }

  /**
   * horarios findMany
   */
  export type horariosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horarios
     */
    select?: horariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horarios
     */
    omit?: horariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horariosInclude<ExtArgs> | null
    /**
     * Filter, which horarios to fetch.
     */
    where?: horariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of horarios to fetch.
     */
    orderBy?: horariosOrderByWithRelationInput | horariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing horarios.
     */
    cursor?: horariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` horarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` horarios.
     */
    skip?: number
    distinct?: HorariosScalarFieldEnum | HorariosScalarFieldEnum[]
  }

  /**
   * horarios create
   */
  export type horariosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horarios
     */
    select?: horariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horarios
     */
    omit?: horariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horariosInclude<ExtArgs> | null
    /**
     * The data needed to create a horarios.
     */
    data: XOR<horariosCreateInput, horariosUncheckedCreateInput>
  }

  /**
   * horarios createMany
   */
  export type horariosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many horarios.
     */
    data: horariosCreateManyInput | horariosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * horarios createManyAndReturn
   */
  export type horariosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horarios
     */
    select?: horariosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the horarios
     */
    omit?: horariosOmit<ExtArgs> | null
    /**
     * The data used to create many horarios.
     */
    data: horariosCreateManyInput | horariosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horariosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * horarios update
   */
  export type horariosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horarios
     */
    select?: horariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horarios
     */
    omit?: horariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horariosInclude<ExtArgs> | null
    /**
     * The data needed to update a horarios.
     */
    data: XOR<horariosUpdateInput, horariosUncheckedUpdateInput>
    /**
     * Choose, which horarios to update.
     */
    where: horariosWhereUniqueInput
  }

  /**
   * horarios updateMany
   */
  export type horariosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update horarios.
     */
    data: XOR<horariosUpdateManyMutationInput, horariosUncheckedUpdateManyInput>
    /**
     * Filter which horarios to update
     */
    where?: horariosWhereInput
    /**
     * Limit how many horarios to update.
     */
    limit?: number
  }

  /**
   * horarios updateManyAndReturn
   */
  export type horariosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horarios
     */
    select?: horariosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the horarios
     */
    omit?: horariosOmit<ExtArgs> | null
    /**
     * The data used to update horarios.
     */
    data: XOR<horariosUpdateManyMutationInput, horariosUncheckedUpdateManyInput>
    /**
     * Filter which horarios to update
     */
    where?: horariosWhereInput
    /**
     * Limit how many horarios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horariosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * horarios upsert
   */
  export type horariosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horarios
     */
    select?: horariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horarios
     */
    omit?: horariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horariosInclude<ExtArgs> | null
    /**
     * The filter to search for the horarios to update in case it exists.
     */
    where: horariosWhereUniqueInput
    /**
     * In case the horarios found by the `where` argument doesn't exist, create a new horarios with this data.
     */
    create: XOR<horariosCreateInput, horariosUncheckedCreateInput>
    /**
     * In case the horarios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<horariosUpdateInput, horariosUncheckedUpdateInput>
  }

  /**
   * horarios delete
   */
  export type horariosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horarios
     */
    select?: horariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horarios
     */
    omit?: horariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horariosInclude<ExtArgs> | null
    /**
     * Filter which horarios to delete.
     */
    where: horariosWhereUniqueInput
  }

  /**
   * horarios deleteMany
   */
  export type horariosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which horarios to delete
     */
    where?: horariosWhereInput
    /**
     * Limit how many horarios to delete.
     */
    limit?: number
  }

  /**
   * horarios without action
   */
  export type horariosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horarios
     */
    select?: horariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horarios
     */
    omit?: horariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horariosInclude<ExtArgs> | null
  }


  /**
   * Model medicos
   */

  export type AggregateMedicos = {
    _count: MedicosCountAggregateOutputType | null
    _avg: MedicosAvgAggregateOutputType | null
    _sum: MedicosSumAggregateOutputType | null
    _min: MedicosMinAggregateOutputType | null
    _max: MedicosMaxAggregateOutputType | null
  }

  export type MedicosAvgAggregateOutputType = {
    id_medico: number | null
    id_especialidad: number | null
  }

  export type MedicosSumAggregateOutputType = {
    id_medico: number | null
    id_especialidad: number | null
  }

  export type MedicosMinAggregateOutputType = {
    id_medico: number | null
    nombres: string | null
    apellidos: string | null
    correo: string | null
    celular: string | null
    id_especialidad: number | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_actualizacion: Date | null
  }

  export type MedicosMaxAggregateOutputType = {
    id_medico: number | null
    nombres: string | null
    apellidos: string | null
    correo: string | null
    celular: string | null
    id_especialidad: number | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_actualizacion: Date | null
  }

  export type MedicosCountAggregateOutputType = {
    id_medico: number
    nombres: number
    apellidos: number
    correo: number
    celular: number
    id_especialidad: number
    estado_auditoria: number
    fecha_creacion: number
    fecha_actualizacion: number
    _all: number
  }


  export type MedicosAvgAggregateInputType = {
    id_medico?: true
    id_especialidad?: true
  }

  export type MedicosSumAggregateInputType = {
    id_medico?: true
    id_especialidad?: true
  }

  export type MedicosMinAggregateInputType = {
    id_medico?: true
    nombres?: true
    apellidos?: true
    correo?: true
    celular?: true
    id_especialidad?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_actualizacion?: true
  }

  export type MedicosMaxAggregateInputType = {
    id_medico?: true
    nombres?: true
    apellidos?: true
    correo?: true
    celular?: true
    id_especialidad?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_actualizacion?: true
  }

  export type MedicosCountAggregateInputType = {
    id_medico?: true
    nombres?: true
    apellidos?: true
    correo?: true
    celular?: true
    id_especialidad?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_actualizacion?: true
    _all?: true
  }

  export type MedicosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medicos to aggregate.
     */
    where?: medicosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicos to fetch.
     */
    orderBy?: medicosOrderByWithRelationInput | medicosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: medicosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned medicos
    **/
    _count?: true | MedicosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicosMaxAggregateInputType
  }

  export type GetMedicosAggregateType<T extends MedicosAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicos[P]>
      : GetScalarType<T[P], AggregateMedicos[P]>
  }




  export type medicosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medicosWhereInput
    orderBy?: medicosOrderByWithAggregationInput | medicosOrderByWithAggregationInput[]
    by: MedicosScalarFieldEnum[] | MedicosScalarFieldEnum
    having?: medicosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicosCountAggregateInputType | true
    _avg?: MedicosAvgAggregateInputType
    _sum?: MedicosSumAggregateInputType
    _min?: MedicosMinAggregateInputType
    _max?: MedicosMaxAggregateInputType
  }

  export type MedicosGroupByOutputType = {
    id_medico: number
    nombres: string
    apellidos: string
    correo: string | null
    celular: string | null
    id_especialidad: number
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_actualizacion: Date | null
    _count: MedicosCountAggregateOutputType | null
    _avg: MedicosAvgAggregateOutputType | null
    _sum: MedicosSumAggregateOutputType | null
    _min: MedicosMinAggregateOutputType | null
    _max: MedicosMaxAggregateOutputType | null
  }

  type GetMedicosGroupByPayload<T extends medicosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicosGroupByOutputType[P]>
            : GetScalarType<T[P], MedicosGroupByOutputType[P]>
        }
      >
    >


  export type medicosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_medico?: boolean
    nombres?: boolean
    apellidos?: boolean
    correo?: boolean
    celular?: boolean
    id_especialidad?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_actualizacion?: boolean
    citas?: boolean | medicos$citasArgs<ExtArgs>
    horarios?: boolean | medicos$horariosArgs<ExtArgs>
    especialidades?: boolean | especialidadesDefaultArgs<ExtArgs>
    _count?: boolean | MedicosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicos"]>

  export type medicosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_medico?: boolean
    nombres?: boolean
    apellidos?: boolean
    correo?: boolean
    celular?: boolean
    id_especialidad?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_actualizacion?: boolean
    especialidades?: boolean | especialidadesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicos"]>

  export type medicosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_medico?: boolean
    nombres?: boolean
    apellidos?: boolean
    correo?: boolean
    celular?: boolean
    id_especialidad?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_actualizacion?: boolean
    especialidades?: boolean | especialidadesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicos"]>

  export type medicosSelectScalar = {
    id_medico?: boolean
    nombres?: boolean
    apellidos?: boolean
    correo?: boolean
    celular?: boolean
    id_especialidad?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_actualizacion?: boolean
  }

  export type medicosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_medico" | "nombres" | "apellidos" | "correo" | "celular" | "id_especialidad" | "estado_auditoria" | "fecha_creacion" | "fecha_actualizacion", ExtArgs["result"]["medicos"]>
  export type medicosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    citas?: boolean | medicos$citasArgs<ExtArgs>
    horarios?: boolean | medicos$horariosArgs<ExtArgs>
    especialidades?: boolean | especialidadesDefaultArgs<ExtArgs>
    _count?: boolean | MedicosCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type medicosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    especialidades?: boolean | especialidadesDefaultArgs<ExtArgs>
  }
  export type medicosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    especialidades?: boolean | especialidadesDefaultArgs<ExtArgs>
  }

  export type $medicosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "medicos"
    objects: {
      citas: Prisma.$citasPayload<ExtArgs>[]
      horarios: Prisma.$horariosPayload<ExtArgs>[]
      especialidades: Prisma.$especialidadesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_medico: number
      nombres: string
      apellidos: string
      correo: string | null
      celular: string | null
      id_especialidad: number
      estado_auditoria: string | null
      fecha_creacion: Date | null
      fecha_actualizacion: Date | null
    }, ExtArgs["result"]["medicos"]>
    composites: {}
  }

  type medicosGetPayload<S extends boolean | null | undefined | medicosDefaultArgs> = $Result.GetResult<Prisma.$medicosPayload, S>

  type medicosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<medicosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicosCountAggregateInputType | true
    }

  export interface medicosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['medicos'], meta: { name: 'medicos' } }
    /**
     * Find zero or one Medicos that matches the filter.
     * @param {medicosFindUniqueArgs} args - Arguments to find a Medicos
     * @example
     * // Get one Medicos
     * const medicos = await prisma.medicos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends medicosFindUniqueArgs>(args: SelectSubset<T, medicosFindUniqueArgs<ExtArgs>>): Prisma__medicosClient<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Medicos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {medicosFindUniqueOrThrowArgs} args - Arguments to find a Medicos
     * @example
     * // Get one Medicos
     * const medicos = await prisma.medicos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends medicosFindUniqueOrThrowArgs>(args: SelectSubset<T, medicosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__medicosClient<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medicos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicosFindFirstArgs} args - Arguments to find a Medicos
     * @example
     * // Get one Medicos
     * const medicos = await prisma.medicos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends medicosFindFirstArgs>(args?: SelectSubset<T, medicosFindFirstArgs<ExtArgs>>): Prisma__medicosClient<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medicos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicosFindFirstOrThrowArgs} args - Arguments to find a Medicos
     * @example
     * // Get one Medicos
     * const medicos = await prisma.medicos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends medicosFindFirstOrThrowArgs>(args?: SelectSubset<T, medicosFindFirstOrThrowArgs<ExtArgs>>): Prisma__medicosClient<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Medicos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medicos
     * const medicos = await prisma.medicos.findMany()
     * 
     * // Get first 10 Medicos
     * const medicos = await prisma.medicos.findMany({ take: 10 })
     * 
     * // Only select the `id_medico`
     * const medicosWithId_medicoOnly = await prisma.medicos.findMany({ select: { id_medico: true } })
     * 
     */
    findMany<T extends medicosFindManyArgs>(args?: SelectSubset<T, medicosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Medicos.
     * @param {medicosCreateArgs} args - Arguments to create a Medicos.
     * @example
     * // Create one Medicos
     * const Medicos = await prisma.medicos.create({
     *   data: {
     *     // ... data to create a Medicos
     *   }
     * })
     * 
     */
    create<T extends medicosCreateArgs>(args: SelectSubset<T, medicosCreateArgs<ExtArgs>>): Prisma__medicosClient<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Medicos.
     * @param {medicosCreateManyArgs} args - Arguments to create many Medicos.
     * @example
     * // Create many Medicos
     * const medicos = await prisma.medicos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends medicosCreateManyArgs>(args?: SelectSubset<T, medicosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Medicos and returns the data saved in the database.
     * @param {medicosCreateManyAndReturnArgs} args - Arguments to create many Medicos.
     * @example
     * // Create many Medicos
     * const medicos = await prisma.medicos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Medicos and only return the `id_medico`
     * const medicosWithId_medicoOnly = await prisma.medicos.createManyAndReturn({
     *   select: { id_medico: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends medicosCreateManyAndReturnArgs>(args?: SelectSubset<T, medicosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Medicos.
     * @param {medicosDeleteArgs} args - Arguments to delete one Medicos.
     * @example
     * // Delete one Medicos
     * const Medicos = await prisma.medicos.delete({
     *   where: {
     *     // ... filter to delete one Medicos
     *   }
     * })
     * 
     */
    delete<T extends medicosDeleteArgs>(args: SelectSubset<T, medicosDeleteArgs<ExtArgs>>): Prisma__medicosClient<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Medicos.
     * @param {medicosUpdateArgs} args - Arguments to update one Medicos.
     * @example
     * // Update one Medicos
     * const medicos = await prisma.medicos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends medicosUpdateArgs>(args: SelectSubset<T, medicosUpdateArgs<ExtArgs>>): Prisma__medicosClient<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Medicos.
     * @param {medicosDeleteManyArgs} args - Arguments to filter Medicos to delete.
     * @example
     * // Delete a few Medicos
     * const { count } = await prisma.medicos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends medicosDeleteManyArgs>(args?: SelectSubset<T, medicosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medicos
     * const medicos = await prisma.medicos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends medicosUpdateManyArgs>(args: SelectSubset<T, medicosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medicos and returns the data updated in the database.
     * @param {medicosUpdateManyAndReturnArgs} args - Arguments to update many Medicos.
     * @example
     * // Update many Medicos
     * const medicos = await prisma.medicos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Medicos and only return the `id_medico`
     * const medicosWithId_medicoOnly = await prisma.medicos.updateManyAndReturn({
     *   select: { id_medico: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends medicosUpdateManyAndReturnArgs>(args: SelectSubset<T, medicosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Medicos.
     * @param {medicosUpsertArgs} args - Arguments to update or create a Medicos.
     * @example
     * // Update or create a Medicos
     * const medicos = await prisma.medicos.upsert({
     *   create: {
     *     // ... data to create a Medicos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medicos we want to update
     *   }
     * })
     */
    upsert<T extends medicosUpsertArgs>(args: SelectSubset<T, medicosUpsertArgs<ExtArgs>>): Prisma__medicosClient<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Medicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicosCountArgs} args - Arguments to filter Medicos to count.
     * @example
     * // Count the number of Medicos
     * const count = await prisma.medicos.count({
     *   where: {
     *     // ... the filter for the Medicos we want to count
     *   }
     * })
    **/
    count<T extends medicosCountArgs>(
      args?: Subset<T, medicosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicosAggregateArgs>(args: Subset<T, MedicosAggregateArgs>): Prisma.PrismaPromise<GetMedicosAggregateType<T>>

    /**
     * Group by Medicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends medicosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: medicosGroupByArgs['orderBy'] }
        : { orderBy?: medicosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, medicosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the medicos model
   */
  readonly fields: medicosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for medicos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__medicosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    citas<T extends medicos$citasArgs<ExtArgs> = {}>(args?: Subset<T, medicos$citasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$citasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    horarios<T extends medicos$horariosArgs<ExtArgs> = {}>(args?: Subset<T, medicos$horariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$horariosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    especialidades<T extends especialidadesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, especialidadesDefaultArgs<ExtArgs>>): Prisma__especialidadesClient<$Result.GetResult<Prisma.$especialidadesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the medicos model
   */
  interface medicosFieldRefs {
    readonly id_medico: FieldRef<"medicos", 'Int'>
    readonly nombres: FieldRef<"medicos", 'String'>
    readonly apellidos: FieldRef<"medicos", 'String'>
    readonly correo: FieldRef<"medicos", 'String'>
    readonly celular: FieldRef<"medicos", 'String'>
    readonly id_especialidad: FieldRef<"medicos", 'Int'>
    readonly estado_auditoria: FieldRef<"medicos", 'String'>
    readonly fecha_creacion: FieldRef<"medicos", 'DateTime'>
    readonly fecha_actualizacion: FieldRef<"medicos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * medicos findUnique
   */
  export type medicosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicos
     */
    select?: medicosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicos
     */
    omit?: medicosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicosInclude<ExtArgs> | null
    /**
     * Filter, which medicos to fetch.
     */
    where: medicosWhereUniqueInput
  }

  /**
   * medicos findUniqueOrThrow
   */
  export type medicosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicos
     */
    select?: medicosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicos
     */
    omit?: medicosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicosInclude<ExtArgs> | null
    /**
     * Filter, which medicos to fetch.
     */
    where: medicosWhereUniqueInput
  }

  /**
   * medicos findFirst
   */
  export type medicosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicos
     */
    select?: medicosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicos
     */
    omit?: medicosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicosInclude<ExtArgs> | null
    /**
     * Filter, which medicos to fetch.
     */
    where?: medicosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicos to fetch.
     */
    orderBy?: medicosOrderByWithRelationInput | medicosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medicos.
     */
    cursor?: medicosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medicos.
     */
    distinct?: MedicosScalarFieldEnum | MedicosScalarFieldEnum[]
  }

  /**
   * medicos findFirstOrThrow
   */
  export type medicosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicos
     */
    select?: medicosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicos
     */
    omit?: medicosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicosInclude<ExtArgs> | null
    /**
     * Filter, which medicos to fetch.
     */
    where?: medicosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicos to fetch.
     */
    orderBy?: medicosOrderByWithRelationInput | medicosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medicos.
     */
    cursor?: medicosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medicos.
     */
    distinct?: MedicosScalarFieldEnum | MedicosScalarFieldEnum[]
  }

  /**
   * medicos findMany
   */
  export type medicosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicos
     */
    select?: medicosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicos
     */
    omit?: medicosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicosInclude<ExtArgs> | null
    /**
     * Filter, which medicos to fetch.
     */
    where?: medicosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicos to fetch.
     */
    orderBy?: medicosOrderByWithRelationInput | medicosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing medicos.
     */
    cursor?: medicosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicos.
     */
    skip?: number
    distinct?: MedicosScalarFieldEnum | MedicosScalarFieldEnum[]
  }

  /**
   * medicos create
   */
  export type medicosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicos
     */
    select?: medicosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicos
     */
    omit?: medicosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicosInclude<ExtArgs> | null
    /**
     * The data needed to create a medicos.
     */
    data: XOR<medicosCreateInput, medicosUncheckedCreateInput>
  }

  /**
   * medicos createMany
   */
  export type medicosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many medicos.
     */
    data: medicosCreateManyInput | medicosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * medicos createManyAndReturn
   */
  export type medicosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicos
     */
    select?: medicosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the medicos
     */
    omit?: medicosOmit<ExtArgs> | null
    /**
     * The data used to create many medicos.
     */
    data: medicosCreateManyInput | medicosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * medicos update
   */
  export type medicosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicos
     */
    select?: medicosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicos
     */
    omit?: medicosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicosInclude<ExtArgs> | null
    /**
     * The data needed to update a medicos.
     */
    data: XOR<medicosUpdateInput, medicosUncheckedUpdateInput>
    /**
     * Choose, which medicos to update.
     */
    where: medicosWhereUniqueInput
  }

  /**
   * medicos updateMany
   */
  export type medicosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update medicos.
     */
    data: XOR<medicosUpdateManyMutationInput, medicosUncheckedUpdateManyInput>
    /**
     * Filter which medicos to update
     */
    where?: medicosWhereInput
    /**
     * Limit how many medicos to update.
     */
    limit?: number
  }

  /**
   * medicos updateManyAndReturn
   */
  export type medicosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicos
     */
    select?: medicosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the medicos
     */
    omit?: medicosOmit<ExtArgs> | null
    /**
     * The data used to update medicos.
     */
    data: XOR<medicosUpdateManyMutationInput, medicosUncheckedUpdateManyInput>
    /**
     * Filter which medicos to update
     */
    where?: medicosWhereInput
    /**
     * Limit how many medicos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * medicos upsert
   */
  export type medicosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicos
     */
    select?: medicosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicos
     */
    omit?: medicosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicosInclude<ExtArgs> | null
    /**
     * The filter to search for the medicos to update in case it exists.
     */
    where: medicosWhereUniqueInput
    /**
     * In case the medicos found by the `where` argument doesn't exist, create a new medicos with this data.
     */
    create: XOR<medicosCreateInput, medicosUncheckedCreateInput>
    /**
     * In case the medicos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<medicosUpdateInput, medicosUncheckedUpdateInput>
  }

  /**
   * medicos delete
   */
  export type medicosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicos
     */
    select?: medicosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicos
     */
    omit?: medicosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicosInclude<ExtArgs> | null
    /**
     * Filter which medicos to delete.
     */
    where: medicosWhereUniqueInput
  }

  /**
   * medicos deleteMany
   */
  export type medicosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medicos to delete
     */
    where?: medicosWhereInput
    /**
     * Limit how many medicos to delete.
     */
    limit?: number
  }

  /**
   * medicos.citas
   */
  export type medicos$citasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the citas
     */
    select?: citasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the citas
     */
    omit?: citasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citasInclude<ExtArgs> | null
    where?: citasWhereInput
    orderBy?: citasOrderByWithRelationInput | citasOrderByWithRelationInput[]
    cursor?: citasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CitasScalarFieldEnum | CitasScalarFieldEnum[]
  }

  /**
   * medicos.horarios
   */
  export type medicos$horariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horarios
     */
    select?: horariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horarios
     */
    omit?: horariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horariosInclude<ExtArgs> | null
    where?: horariosWhereInput
    orderBy?: horariosOrderByWithRelationInput | horariosOrderByWithRelationInput[]
    cursor?: horariosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HorariosScalarFieldEnum | HorariosScalarFieldEnum[]
  }

  /**
   * medicos without action
   */
  export type medicosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicos
     */
    select?: medicosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medicos
     */
    omit?: medicosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicosInclude<ExtArgs> | null
  }


  /**
   * Model pacientes
   */

  export type AggregatePacientes = {
    _count: PacientesCountAggregateOutputType | null
    _avg: PacientesAvgAggregateOutputType | null
    _sum: PacientesSumAggregateOutputType | null
    _min: PacientesMinAggregateOutputType | null
    _max: PacientesMaxAggregateOutputType | null
  }

  export type PacientesAvgAggregateOutputType = {
    id_paciente: number | null
    edad: number | null
    id_tipo_documento: number | null
  }

  export type PacientesSumAggregateOutputType = {
    id_paciente: number | null
    edad: number | null
    id_tipo_documento: number | null
  }

  export type PacientesMinAggregateOutputType = {
    id_paciente: number | null
    nombres: string | null
    apellidos: string | null
    edad: number | null
    fecha_nacimiento: Date | null
    id_tipo_documento: number | null
    numero_documento: string | null
    direccion: string | null
    correo: string | null
    genero: string | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_actualizacion: Date | null
  }

  export type PacientesMaxAggregateOutputType = {
    id_paciente: number | null
    nombres: string | null
    apellidos: string | null
    edad: number | null
    fecha_nacimiento: Date | null
    id_tipo_documento: number | null
    numero_documento: string | null
    direccion: string | null
    correo: string | null
    genero: string | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_actualizacion: Date | null
  }

  export type PacientesCountAggregateOutputType = {
    id_paciente: number
    nombres: number
    apellidos: number
    edad: number
    fecha_nacimiento: number
    id_tipo_documento: number
    numero_documento: number
    direccion: number
    correo: number
    genero: number
    estado_auditoria: number
    fecha_creacion: number
    fecha_actualizacion: number
    _all: number
  }


  export type PacientesAvgAggregateInputType = {
    id_paciente?: true
    edad?: true
    id_tipo_documento?: true
  }

  export type PacientesSumAggregateInputType = {
    id_paciente?: true
    edad?: true
    id_tipo_documento?: true
  }

  export type PacientesMinAggregateInputType = {
    id_paciente?: true
    nombres?: true
    apellidos?: true
    edad?: true
    fecha_nacimiento?: true
    id_tipo_documento?: true
    numero_documento?: true
    direccion?: true
    correo?: true
    genero?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_actualizacion?: true
  }

  export type PacientesMaxAggregateInputType = {
    id_paciente?: true
    nombres?: true
    apellidos?: true
    edad?: true
    fecha_nacimiento?: true
    id_tipo_documento?: true
    numero_documento?: true
    direccion?: true
    correo?: true
    genero?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_actualizacion?: true
  }

  export type PacientesCountAggregateInputType = {
    id_paciente?: true
    nombres?: true
    apellidos?: true
    edad?: true
    fecha_nacimiento?: true
    id_tipo_documento?: true
    numero_documento?: true
    direccion?: true
    correo?: true
    genero?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_actualizacion?: true
    _all?: true
  }

  export type PacientesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pacientes to aggregate.
     */
    where?: pacientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pacientes to fetch.
     */
    orderBy?: pacientesOrderByWithRelationInput | pacientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pacientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pacientes
    **/
    _count?: true | PacientesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PacientesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PacientesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PacientesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PacientesMaxAggregateInputType
  }

  export type GetPacientesAggregateType<T extends PacientesAggregateArgs> = {
        [P in keyof T & keyof AggregatePacientes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePacientes[P]>
      : GetScalarType<T[P], AggregatePacientes[P]>
  }




  export type pacientesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pacientesWhereInput
    orderBy?: pacientesOrderByWithAggregationInput | pacientesOrderByWithAggregationInput[]
    by: PacientesScalarFieldEnum[] | PacientesScalarFieldEnum
    having?: pacientesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PacientesCountAggregateInputType | true
    _avg?: PacientesAvgAggregateInputType
    _sum?: PacientesSumAggregateInputType
    _min?: PacientesMinAggregateInputType
    _max?: PacientesMaxAggregateInputType
  }

  export type PacientesGroupByOutputType = {
    id_paciente: number
    nombres: string
    apellidos: string
    edad: number | null
    fecha_nacimiento: Date | null
    id_tipo_documento: number
    numero_documento: string
    direccion: string | null
    correo: string | null
    genero: string
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_actualizacion: Date | null
    _count: PacientesCountAggregateOutputType | null
    _avg: PacientesAvgAggregateOutputType | null
    _sum: PacientesSumAggregateOutputType | null
    _min: PacientesMinAggregateOutputType | null
    _max: PacientesMaxAggregateOutputType | null
  }

  type GetPacientesGroupByPayload<T extends pacientesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PacientesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PacientesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PacientesGroupByOutputType[P]>
            : GetScalarType<T[P], PacientesGroupByOutputType[P]>
        }
      >
    >


  export type pacientesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_paciente?: boolean
    nombres?: boolean
    apellidos?: boolean
    edad?: boolean
    fecha_nacimiento?: boolean
    id_tipo_documento?: boolean
    numero_documento?: boolean
    direccion?: boolean
    correo?: boolean
    genero?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_actualizacion?: boolean
    citas?: boolean | pacientes$citasArgs<ExtArgs>
    tipo_documentos?: boolean | tipo_documentosDefaultArgs<ExtArgs>
    _count?: boolean | PacientesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pacientes"]>

  export type pacientesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_paciente?: boolean
    nombres?: boolean
    apellidos?: boolean
    edad?: boolean
    fecha_nacimiento?: boolean
    id_tipo_documento?: boolean
    numero_documento?: boolean
    direccion?: boolean
    correo?: boolean
    genero?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_actualizacion?: boolean
    tipo_documentos?: boolean | tipo_documentosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pacientes"]>

  export type pacientesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_paciente?: boolean
    nombres?: boolean
    apellidos?: boolean
    edad?: boolean
    fecha_nacimiento?: boolean
    id_tipo_documento?: boolean
    numero_documento?: boolean
    direccion?: boolean
    correo?: boolean
    genero?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_actualizacion?: boolean
    tipo_documentos?: boolean | tipo_documentosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pacientes"]>

  export type pacientesSelectScalar = {
    id_paciente?: boolean
    nombres?: boolean
    apellidos?: boolean
    edad?: boolean
    fecha_nacimiento?: boolean
    id_tipo_documento?: boolean
    numero_documento?: boolean
    direccion?: boolean
    correo?: boolean
    genero?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_actualizacion?: boolean
  }

  export type pacientesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_paciente" | "nombres" | "apellidos" | "edad" | "fecha_nacimiento" | "id_tipo_documento" | "numero_documento" | "direccion" | "correo" | "genero" | "estado_auditoria" | "fecha_creacion" | "fecha_actualizacion", ExtArgs["result"]["pacientes"]>
  export type pacientesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    citas?: boolean | pacientes$citasArgs<ExtArgs>
    tipo_documentos?: boolean | tipo_documentosDefaultArgs<ExtArgs>
    _count?: boolean | PacientesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type pacientesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tipo_documentos?: boolean | tipo_documentosDefaultArgs<ExtArgs>
  }
  export type pacientesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tipo_documentos?: boolean | tipo_documentosDefaultArgs<ExtArgs>
  }

  export type $pacientesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pacientes"
    objects: {
      citas: Prisma.$citasPayload<ExtArgs>[]
      tipo_documentos: Prisma.$tipo_documentosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_paciente: number
      nombres: string
      apellidos: string
      edad: number | null
      fecha_nacimiento: Date | null
      id_tipo_documento: number
      numero_documento: string
      direccion: string | null
      correo: string | null
      genero: string
      estado_auditoria: string | null
      fecha_creacion: Date | null
      fecha_actualizacion: Date | null
    }, ExtArgs["result"]["pacientes"]>
    composites: {}
  }

  type pacientesGetPayload<S extends boolean | null | undefined | pacientesDefaultArgs> = $Result.GetResult<Prisma.$pacientesPayload, S>

  type pacientesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pacientesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PacientesCountAggregateInputType | true
    }

  export interface pacientesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pacientes'], meta: { name: 'pacientes' } }
    /**
     * Find zero or one Pacientes that matches the filter.
     * @param {pacientesFindUniqueArgs} args - Arguments to find a Pacientes
     * @example
     * // Get one Pacientes
     * const pacientes = await prisma.pacientes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pacientesFindUniqueArgs>(args: SelectSubset<T, pacientesFindUniqueArgs<ExtArgs>>): Prisma__pacientesClient<$Result.GetResult<Prisma.$pacientesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pacientes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pacientesFindUniqueOrThrowArgs} args - Arguments to find a Pacientes
     * @example
     * // Get one Pacientes
     * const pacientes = await prisma.pacientes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pacientesFindUniqueOrThrowArgs>(args: SelectSubset<T, pacientesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pacientesClient<$Result.GetResult<Prisma.$pacientesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pacientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacientesFindFirstArgs} args - Arguments to find a Pacientes
     * @example
     * // Get one Pacientes
     * const pacientes = await prisma.pacientes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pacientesFindFirstArgs>(args?: SelectSubset<T, pacientesFindFirstArgs<ExtArgs>>): Prisma__pacientesClient<$Result.GetResult<Prisma.$pacientesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pacientes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacientesFindFirstOrThrowArgs} args - Arguments to find a Pacientes
     * @example
     * // Get one Pacientes
     * const pacientes = await prisma.pacientes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pacientesFindFirstOrThrowArgs>(args?: SelectSubset<T, pacientesFindFirstOrThrowArgs<ExtArgs>>): Prisma__pacientesClient<$Result.GetResult<Prisma.$pacientesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pacientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacientesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pacientes
     * const pacientes = await prisma.pacientes.findMany()
     * 
     * // Get first 10 Pacientes
     * const pacientes = await prisma.pacientes.findMany({ take: 10 })
     * 
     * // Only select the `id_paciente`
     * const pacientesWithId_pacienteOnly = await prisma.pacientes.findMany({ select: { id_paciente: true } })
     * 
     */
    findMany<T extends pacientesFindManyArgs>(args?: SelectSubset<T, pacientesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pacientesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pacientes.
     * @param {pacientesCreateArgs} args - Arguments to create a Pacientes.
     * @example
     * // Create one Pacientes
     * const Pacientes = await prisma.pacientes.create({
     *   data: {
     *     // ... data to create a Pacientes
     *   }
     * })
     * 
     */
    create<T extends pacientesCreateArgs>(args: SelectSubset<T, pacientesCreateArgs<ExtArgs>>): Prisma__pacientesClient<$Result.GetResult<Prisma.$pacientesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pacientes.
     * @param {pacientesCreateManyArgs} args - Arguments to create many Pacientes.
     * @example
     * // Create many Pacientes
     * const pacientes = await prisma.pacientes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pacientesCreateManyArgs>(args?: SelectSubset<T, pacientesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pacientes and returns the data saved in the database.
     * @param {pacientesCreateManyAndReturnArgs} args - Arguments to create many Pacientes.
     * @example
     * // Create many Pacientes
     * const pacientes = await prisma.pacientes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pacientes and only return the `id_paciente`
     * const pacientesWithId_pacienteOnly = await prisma.pacientes.createManyAndReturn({
     *   select: { id_paciente: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pacientesCreateManyAndReturnArgs>(args?: SelectSubset<T, pacientesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pacientesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pacientes.
     * @param {pacientesDeleteArgs} args - Arguments to delete one Pacientes.
     * @example
     * // Delete one Pacientes
     * const Pacientes = await prisma.pacientes.delete({
     *   where: {
     *     // ... filter to delete one Pacientes
     *   }
     * })
     * 
     */
    delete<T extends pacientesDeleteArgs>(args: SelectSubset<T, pacientesDeleteArgs<ExtArgs>>): Prisma__pacientesClient<$Result.GetResult<Prisma.$pacientesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pacientes.
     * @param {pacientesUpdateArgs} args - Arguments to update one Pacientes.
     * @example
     * // Update one Pacientes
     * const pacientes = await prisma.pacientes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pacientesUpdateArgs>(args: SelectSubset<T, pacientesUpdateArgs<ExtArgs>>): Prisma__pacientesClient<$Result.GetResult<Prisma.$pacientesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pacientes.
     * @param {pacientesDeleteManyArgs} args - Arguments to filter Pacientes to delete.
     * @example
     * // Delete a few Pacientes
     * const { count } = await prisma.pacientes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pacientesDeleteManyArgs>(args?: SelectSubset<T, pacientesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pacientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacientesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pacientes
     * const pacientes = await prisma.pacientes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pacientesUpdateManyArgs>(args: SelectSubset<T, pacientesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pacientes and returns the data updated in the database.
     * @param {pacientesUpdateManyAndReturnArgs} args - Arguments to update many Pacientes.
     * @example
     * // Update many Pacientes
     * const pacientes = await prisma.pacientes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pacientes and only return the `id_paciente`
     * const pacientesWithId_pacienteOnly = await prisma.pacientes.updateManyAndReturn({
     *   select: { id_paciente: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends pacientesUpdateManyAndReturnArgs>(args: SelectSubset<T, pacientesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pacientesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pacientes.
     * @param {pacientesUpsertArgs} args - Arguments to update or create a Pacientes.
     * @example
     * // Update or create a Pacientes
     * const pacientes = await prisma.pacientes.upsert({
     *   create: {
     *     // ... data to create a Pacientes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pacientes we want to update
     *   }
     * })
     */
    upsert<T extends pacientesUpsertArgs>(args: SelectSubset<T, pacientesUpsertArgs<ExtArgs>>): Prisma__pacientesClient<$Result.GetResult<Prisma.$pacientesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pacientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacientesCountArgs} args - Arguments to filter Pacientes to count.
     * @example
     * // Count the number of Pacientes
     * const count = await prisma.pacientes.count({
     *   where: {
     *     // ... the filter for the Pacientes we want to count
     *   }
     * })
    **/
    count<T extends pacientesCountArgs>(
      args?: Subset<T, pacientesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PacientesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pacientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PacientesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PacientesAggregateArgs>(args: Subset<T, PacientesAggregateArgs>): Prisma.PrismaPromise<GetPacientesAggregateType<T>>

    /**
     * Group by Pacientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacientesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pacientesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pacientesGroupByArgs['orderBy'] }
        : { orderBy?: pacientesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pacientesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPacientesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pacientes model
   */
  readonly fields: pacientesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pacientes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pacientesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    citas<T extends pacientes$citasArgs<ExtArgs> = {}>(args?: Subset<T, pacientes$citasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$citasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tipo_documentos<T extends tipo_documentosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tipo_documentosDefaultArgs<ExtArgs>>): Prisma__tipo_documentosClient<$Result.GetResult<Prisma.$tipo_documentosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pacientes model
   */
  interface pacientesFieldRefs {
    readonly id_paciente: FieldRef<"pacientes", 'Int'>
    readonly nombres: FieldRef<"pacientes", 'String'>
    readonly apellidos: FieldRef<"pacientes", 'String'>
    readonly edad: FieldRef<"pacientes", 'Int'>
    readonly fecha_nacimiento: FieldRef<"pacientes", 'DateTime'>
    readonly id_tipo_documento: FieldRef<"pacientes", 'Int'>
    readonly numero_documento: FieldRef<"pacientes", 'String'>
    readonly direccion: FieldRef<"pacientes", 'String'>
    readonly correo: FieldRef<"pacientes", 'String'>
    readonly genero: FieldRef<"pacientes", 'String'>
    readonly estado_auditoria: FieldRef<"pacientes", 'String'>
    readonly fecha_creacion: FieldRef<"pacientes", 'DateTime'>
    readonly fecha_actualizacion: FieldRef<"pacientes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * pacientes findUnique
   */
  export type pacientesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacientes
     */
    select?: pacientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacientes
     */
    omit?: pacientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacientesInclude<ExtArgs> | null
    /**
     * Filter, which pacientes to fetch.
     */
    where: pacientesWhereUniqueInput
  }

  /**
   * pacientes findUniqueOrThrow
   */
  export type pacientesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacientes
     */
    select?: pacientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacientes
     */
    omit?: pacientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacientesInclude<ExtArgs> | null
    /**
     * Filter, which pacientes to fetch.
     */
    where: pacientesWhereUniqueInput
  }

  /**
   * pacientes findFirst
   */
  export type pacientesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacientes
     */
    select?: pacientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacientes
     */
    omit?: pacientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacientesInclude<ExtArgs> | null
    /**
     * Filter, which pacientes to fetch.
     */
    where?: pacientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pacientes to fetch.
     */
    orderBy?: pacientesOrderByWithRelationInput | pacientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pacientes.
     */
    cursor?: pacientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pacientes.
     */
    distinct?: PacientesScalarFieldEnum | PacientesScalarFieldEnum[]
  }

  /**
   * pacientes findFirstOrThrow
   */
  export type pacientesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacientes
     */
    select?: pacientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacientes
     */
    omit?: pacientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacientesInclude<ExtArgs> | null
    /**
     * Filter, which pacientes to fetch.
     */
    where?: pacientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pacientes to fetch.
     */
    orderBy?: pacientesOrderByWithRelationInput | pacientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pacientes.
     */
    cursor?: pacientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pacientes.
     */
    distinct?: PacientesScalarFieldEnum | PacientesScalarFieldEnum[]
  }

  /**
   * pacientes findMany
   */
  export type pacientesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacientes
     */
    select?: pacientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacientes
     */
    omit?: pacientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacientesInclude<ExtArgs> | null
    /**
     * Filter, which pacientes to fetch.
     */
    where?: pacientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pacientes to fetch.
     */
    orderBy?: pacientesOrderByWithRelationInput | pacientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pacientes.
     */
    cursor?: pacientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pacientes.
     */
    skip?: number
    distinct?: PacientesScalarFieldEnum | PacientesScalarFieldEnum[]
  }

  /**
   * pacientes create
   */
  export type pacientesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacientes
     */
    select?: pacientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacientes
     */
    omit?: pacientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacientesInclude<ExtArgs> | null
    /**
     * The data needed to create a pacientes.
     */
    data: XOR<pacientesCreateInput, pacientesUncheckedCreateInput>
  }

  /**
   * pacientes createMany
   */
  export type pacientesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pacientes.
     */
    data: pacientesCreateManyInput | pacientesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pacientes createManyAndReturn
   */
  export type pacientesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacientes
     */
    select?: pacientesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pacientes
     */
    omit?: pacientesOmit<ExtArgs> | null
    /**
     * The data used to create many pacientes.
     */
    data: pacientesCreateManyInput | pacientesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacientesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * pacientes update
   */
  export type pacientesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacientes
     */
    select?: pacientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacientes
     */
    omit?: pacientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacientesInclude<ExtArgs> | null
    /**
     * The data needed to update a pacientes.
     */
    data: XOR<pacientesUpdateInput, pacientesUncheckedUpdateInput>
    /**
     * Choose, which pacientes to update.
     */
    where: pacientesWhereUniqueInput
  }

  /**
   * pacientes updateMany
   */
  export type pacientesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pacientes.
     */
    data: XOR<pacientesUpdateManyMutationInput, pacientesUncheckedUpdateManyInput>
    /**
     * Filter which pacientes to update
     */
    where?: pacientesWhereInput
    /**
     * Limit how many pacientes to update.
     */
    limit?: number
  }

  /**
   * pacientes updateManyAndReturn
   */
  export type pacientesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacientes
     */
    select?: pacientesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pacientes
     */
    omit?: pacientesOmit<ExtArgs> | null
    /**
     * The data used to update pacientes.
     */
    data: XOR<pacientesUpdateManyMutationInput, pacientesUncheckedUpdateManyInput>
    /**
     * Filter which pacientes to update
     */
    where?: pacientesWhereInput
    /**
     * Limit how many pacientes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacientesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * pacientes upsert
   */
  export type pacientesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacientes
     */
    select?: pacientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacientes
     */
    omit?: pacientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacientesInclude<ExtArgs> | null
    /**
     * The filter to search for the pacientes to update in case it exists.
     */
    where: pacientesWhereUniqueInput
    /**
     * In case the pacientes found by the `where` argument doesn't exist, create a new pacientes with this data.
     */
    create: XOR<pacientesCreateInput, pacientesUncheckedCreateInput>
    /**
     * In case the pacientes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pacientesUpdateInput, pacientesUncheckedUpdateInput>
  }

  /**
   * pacientes delete
   */
  export type pacientesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacientes
     */
    select?: pacientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacientes
     */
    omit?: pacientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacientesInclude<ExtArgs> | null
    /**
     * Filter which pacientes to delete.
     */
    where: pacientesWhereUniqueInput
  }

  /**
   * pacientes deleteMany
   */
  export type pacientesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pacientes to delete
     */
    where?: pacientesWhereInput
    /**
     * Limit how many pacientes to delete.
     */
    limit?: number
  }

  /**
   * pacientes.citas
   */
  export type pacientes$citasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the citas
     */
    select?: citasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the citas
     */
    omit?: citasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citasInclude<ExtArgs> | null
    where?: citasWhereInput
    orderBy?: citasOrderByWithRelationInput | citasOrderByWithRelationInput[]
    cursor?: citasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CitasScalarFieldEnum | CitasScalarFieldEnum[]
  }

  /**
   * pacientes without action
   */
  export type pacientesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacientes
     */
    select?: pacientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacientes
     */
    omit?: pacientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacientesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Tipo_documentosScalarFieldEnum: {
    id_tipo_documento: 'id_tipo_documento',
    nombre: 'nombre',
    estado_auditoria: 'estado_auditoria',
    fecha_creacion: 'fecha_creacion',
    fecha_actualizacion: 'fecha_actualizacion'
  };

  export type Tipo_documentosScalarFieldEnum = (typeof Tipo_documentosScalarFieldEnum)[keyof typeof Tipo_documentosScalarFieldEnum]


  export const CitasScalarFieldEnum: {
    id_cita: 'id_cita',
    id_paciente: 'id_paciente',
    id_medico: 'id_medico',
    fecha: 'fecha',
    hora: 'hora',
    estado_cita: 'estado_cita',
    estado_auditoria: 'estado_auditoria',
    fecha_creacion: 'fecha_creacion',
    fecha_actualizacion: 'fecha_actualizacion'
  };

  export type CitasScalarFieldEnum = (typeof CitasScalarFieldEnum)[keyof typeof CitasScalarFieldEnum]


  export const EspecialidadesScalarFieldEnum: {
    id_especialidad: 'id_especialidad',
    nombre: 'nombre',
    estado_auditoria: 'estado_auditoria',
    fecha_creacion: 'fecha_creacion',
    fecha_actualizacion: 'fecha_actualizacion'
  };

  export type EspecialidadesScalarFieldEnum = (typeof EspecialidadesScalarFieldEnum)[keyof typeof EspecialidadesScalarFieldEnum]


  export const HorariosScalarFieldEnum: {
    id_horario: 'id_horario',
    id_medico: 'id_medico',
    dia_semana: 'dia_semana',
    hora_inicio: 'hora_inicio',
    hora_fin: 'hora_fin',
    estado_auditoria: 'estado_auditoria',
    fecha_creacion: 'fecha_creacion',
    fecha_actualizacion: 'fecha_actualizacion'
  };

  export type HorariosScalarFieldEnum = (typeof HorariosScalarFieldEnum)[keyof typeof HorariosScalarFieldEnum]


  export const MedicosScalarFieldEnum: {
    id_medico: 'id_medico',
    nombres: 'nombres',
    apellidos: 'apellidos',
    correo: 'correo',
    celular: 'celular',
    id_especialidad: 'id_especialidad',
    estado_auditoria: 'estado_auditoria',
    fecha_creacion: 'fecha_creacion',
    fecha_actualizacion: 'fecha_actualizacion'
  };

  export type MedicosScalarFieldEnum = (typeof MedicosScalarFieldEnum)[keyof typeof MedicosScalarFieldEnum]


  export const PacientesScalarFieldEnum: {
    id_paciente: 'id_paciente',
    nombres: 'nombres',
    apellidos: 'apellidos',
    edad: 'edad',
    fecha_nacimiento: 'fecha_nacimiento',
    id_tipo_documento: 'id_tipo_documento',
    numero_documento: 'numero_documento',
    direccion: 'direccion',
    correo: 'correo',
    genero: 'genero',
    estado_auditoria: 'estado_auditoria',
    fecha_creacion: 'fecha_creacion',
    fecha_actualizacion: 'fecha_actualizacion'
  };

  export type PacientesScalarFieldEnum = (typeof PacientesScalarFieldEnum)[keyof typeof PacientesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type tipo_documentosWhereInput = {
    AND?: tipo_documentosWhereInput | tipo_documentosWhereInput[]
    OR?: tipo_documentosWhereInput[]
    NOT?: tipo_documentosWhereInput | tipo_documentosWhereInput[]
    id_tipo_documento?: IntFilter<"tipo_documentos"> | number
    nombre?: StringFilter<"tipo_documentos"> | string
    estado_auditoria?: StringNullableFilter<"tipo_documentos"> | string | null
    fecha_creacion?: DateTimeNullableFilter<"tipo_documentos"> | Date | string | null
    fecha_actualizacion?: DateTimeNullableFilter<"tipo_documentos"> | Date | string | null
    pacientes?: PacientesListRelationFilter
  }

  export type tipo_documentosOrderByWithRelationInput = {
    id_tipo_documento?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrderInput | SortOrder
    fecha_creacion?: SortOrderInput | SortOrder
    fecha_actualizacion?: SortOrderInput | SortOrder
    pacientes?: pacientesOrderByRelationAggregateInput
  }

  export type tipo_documentosWhereUniqueInput = Prisma.AtLeast<{
    id_tipo_documento?: number
    nombre?: string
    AND?: tipo_documentosWhereInput | tipo_documentosWhereInput[]
    OR?: tipo_documentosWhereInput[]
    NOT?: tipo_documentosWhereInput | tipo_documentosWhereInput[]
    estado_auditoria?: StringNullableFilter<"tipo_documentos"> | string | null
    fecha_creacion?: DateTimeNullableFilter<"tipo_documentos"> | Date | string | null
    fecha_actualizacion?: DateTimeNullableFilter<"tipo_documentos"> | Date | string | null
    pacientes?: PacientesListRelationFilter
  }, "id_tipo_documento" | "nombre">

  export type tipo_documentosOrderByWithAggregationInput = {
    id_tipo_documento?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrderInput | SortOrder
    fecha_creacion?: SortOrderInput | SortOrder
    fecha_actualizacion?: SortOrderInput | SortOrder
    _count?: tipo_documentosCountOrderByAggregateInput
    _avg?: tipo_documentosAvgOrderByAggregateInput
    _max?: tipo_documentosMaxOrderByAggregateInput
    _min?: tipo_documentosMinOrderByAggregateInput
    _sum?: tipo_documentosSumOrderByAggregateInput
  }

  export type tipo_documentosScalarWhereWithAggregatesInput = {
    AND?: tipo_documentosScalarWhereWithAggregatesInput | tipo_documentosScalarWhereWithAggregatesInput[]
    OR?: tipo_documentosScalarWhereWithAggregatesInput[]
    NOT?: tipo_documentosScalarWhereWithAggregatesInput | tipo_documentosScalarWhereWithAggregatesInput[]
    id_tipo_documento?: IntWithAggregatesFilter<"tipo_documentos"> | number
    nombre?: StringWithAggregatesFilter<"tipo_documentos"> | string
    estado_auditoria?: StringNullableWithAggregatesFilter<"tipo_documentos"> | string | null
    fecha_creacion?: DateTimeNullableWithAggregatesFilter<"tipo_documentos"> | Date | string | null
    fecha_actualizacion?: DateTimeNullableWithAggregatesFilter<"tipo_documentos"> | Date | string | null
  }

  export type citasWhereInput = {
    AND?: citasWhereInput | citasWhereInput[]
    OR?: citasWhereInput[]
    NOT?: citasWhereInput | citasWhereInput[]
    id_cita?: IntFilter<"citas"> | number
    id_paciente?: IntFilter<"citas"> | number
    id_medico?: IntFilter<"citas"> | number
    fecha?: DateTimeFilter<"citas"> | Date | string
    hora?: DateTimeFilter<"citas"> | Date | string
    estado_cita?: StringNullableFilter<"citas"> | string | null
    estado_auditoria?: StringNullableFilter<"citas"> | string | null
    fecha_creacion?: DateTimeNullableFilter<"citas"> | Date | string | null
    fecha_actualizacion?: DateTimeNullableFilter<"citas"> | Date | string | null
    medicos?: XOR<MedicosScalarRelationFilter, medicosWhereInput>
    pacientes?: XOR<PacientesScalarRelationFilter, pacientesWhereInput>
  }

  export type citasOrderByWithRelationInput = {
    id_cita?: SortOrder
    id_paciente?: SortOrder
    id_medico?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    estado_cita?: SortOrderInput | SortOrder
    estado_auditoria?: SortOrderInput | SortOrder
    fecha_creacion?: SortOrderInput | SortOrder
    fecha_actualizacion?: SortOrderInput | SortOrder
    medicos?: medicosOrderByWithRelationInput
    pacientes?: pacientesOrderByWithRelationInput
  }

  export type citasWhereUniqueInput = Prisma.AtLeast<{
    id_cita?: number
    AND?: citasWhereInput | citasWhereInput[]
    OR?: citasWhereInput[]
    NOT?: citasWhereInput | citasWhereInput[]
    id_paciente?: IntFilter<"citas"> | number
    id_medico?: IntFilter<"citas"> | number
    fecha?: DateTimeFilter<"citas"> | Date | string
    hora?: DateTimeFilter<"citas"> | Date | string
    estado_cita?: StringNullableFilter<"citas"> | string | null
    estado_auditoria?: StringNullableFilter<"citas"> | string | null
    fecha_creacion?: DateTimeNullableFilter<"citas"> | Date | string | null
    fecha_actualizacion?: DateTimeNullableFilter<"citas"> | Date | string | null
    medicos?: XOR<MedicosScalarRelationFilter, medicosWhereInput>
    pacientes?: XOR<PacientesScalarRelationFilter, pacientesWhereInput>
  }, "id_cita">

  export type citasOrderByWithAggregationInput = {
    id_cita?: SortOrder
    id_paciente?: SortOrder
    id_medico?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    estado_cita?: SortOrderInput | SortOrder
    estado_auditoria?: SortOrderInput | SortOrder
    fecha_creacion?: SortOrderInput | SortOrder
    fecha_actualizacion?: SortOrderInput | SortOrder
    _count?: citasCountOrderByAggregateInput
    _avg?: citasAvgOrderByAggregateInput
    _max?: citasMaxOrderByAggregateInput
    _min?: citasMinOrderByAggregateInput
    _sum?: citasSumOrderByAggregateInput
  }

  export type citasScalarWhereWithAggregatesInput = {
    AND?: citasScalarWhereWithAggregatesInput | citasScalarWhereWithAggregatesInput[]
    OR?: citasScalarWhereWithAggregatesInput[]
    NOT?: citasScalarWhereWithAggregatesInput | citasScalarWhereWithAggregatesInput[]
    id_cita?: IntWithAggregatesFilter<"citas"> | number
    id_paciente?: IntWithAggregatesFilter<"citas"> | number
    id_medico?: IntWithAggregatesFilter<"citas"> | number
    fecha?: DateTimeWithAggregatesFilter<"citas"> | Date | string
    hora?: DateTimeWithAggregatesFilter<"citas"> | Date | string
    estado_cita?: StringNullableWithAggregatesFilter<"citas"> | string | null
    estado_auditoria?: StringNullableWithAggregatesFilter<"citas"> | string | null
    fecha_creacion?: DateTimeNullableWithAggregatesFilter<"citas"> | Date | string | null
    fecha_actualizacion?: DateTimeNullableWithAggregatesFilter<"citas"> | Date | string | null
  }

  export type especialidadesWhereInput = {
    AND?: especialidadesWhereInput | especialidadesWhereInput[]
    OR?: especialidadesWhereInput[]
    NOT?: especialidadesWhereInput | especialidadesWhereInput[]
    id_especialidad?: IntFilter<"especialidades"> | number
    nombre?: StringFilter<"especialidades"> | string
    estado_auditoria?: StringNullableFilter<"especialidades"> | string | null
    fecha_creacion?: DateTimeNullableFilter<"especialidades"> | Date | string | null
    fecha_actualizacion?: DateTimeNullableFilter<"especialidades"> | Date | string | null
    medicos?: MedicosListRelationFilter
  }

  export type especialidadesOrderByWithRelationInput = {
    id_especialidad?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrderInput | SortOrder
    fecha_creacion?: SortOrderInput | SortOrder
    fecha_actualizacion?: SortOrderInput | SortOrder
    medicos?: medicosOrderByRelationAggregateInput
  }

  export type especialidadesWhereUniqueInput = Prisma.AtLeast<{
    id_especialidad?: number
    nombre?: string
    AND?: especialidadesWhereInput | especialidadesWhereInput[]
    OR?: especialidadesWhereInput[]
    NOT?: especialidadesWhereInput | especialidadesWhereInput[]
    estado_auditoria?: StringNullableFilter<"especialidades"> | string | null
    fecha_creacion?: DateTimeNullableFilter<"especialidades"> | Date | string | null
    fecha_actualizacion?: DateTimeNullableFilter<"especialidades"> | Date | string | null
    medicos?: MedicosListRelationFilter
  }, "id_especialidad" | "nombre">

  export type especialidadesOrderByWithAggregationInput = {
    id_especialidad?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrderInput | SortOrder
    fecha_creacion?: SortOrderInput | SortOrder
    fecha_actualizacion?: SortOrderInput | SortOrder
    _count?: especialidadesCountOrderByAggregateInput
    _avg?: especialidadesAvgOrderByAggregateInput
    _max?: especialidadesMaxOrderByAggregateInput
    _min?: especialidadesMinOrderByAggregateInput
    _sum?: especialidadesSumOrderByAggregateInput
  }

  export type especialidadesScalarWhereWithAggregatesInput = {
    AND?: especialidadesScalarWhereWithAggregatesInput | especialidadesScalarWhereWithAggregatesInput[]
    OR?: especialidadesScalarWhereWithAggregatesInput[]
    NOT?: especialidadesScalarWhereWithAggregatesInput | especialidadesScalarWhereWithAggregatesInput[]
    id_especialidad?: IntWithAggregatesFilter<"especialidades"> | number
    nombre?: StringWithAggregatesFilter<"especialidades"> | string
    estado_auditoria?: StringNullableWithAggregatesFilter<"especialidades"> | string | null
    fecha_creacion?: DateTimeNullableWithAggregatesFilter<"especialidades"> | Date | string | null
    fecha_actualizacion?: DateTimeNullableWithAggregatesFilter<"especialidades"> | Date | string | null
  }

  export type horariosWhereInput = {
    AND?: horariosWhereInput | horariosWhereInput[]
    OR?: horariosWhereInput[]
    NOT?: horariosWhereInput | horariosWhereInput[]
    id_horario?: IntFilter<"horarios"> | number
    id_medico?: IntFilter<"horarios"> | number
    dia_semana?: StringFilter<"horarios"> | string
    hora_inicio?: DateTimeFilter<"horarios"> | Date | string
    hora_fin?: DateTimeFilter<"horarios"> | Date | string
    estado_auditoria?: StringNullableFilter<"horarios"> | string | null
    fecha_creacion?: DateTimeNullableFilter<"horarios"> | Date | string | null
    fecha_actualizacion?: DateTimeNullableFilter<"horarios"> | Date | string | null
    medicos?: XOR<MedicosScalarRelationFilter, medicosWhereInput>
  }

  export type horariosOrderByWithRelationInput = {
    id_horario?: SortOrder
    id_medico?: SortOrder
    dia_semana?: SortOrder
    hora_inicio?: SortOrder
    hora_fin?: SortOrder
    estado_auditoria?: SortOrderInput | SortOrder
    fecha_creacion?: SortOrderInput | SortOrder
    fecha_actualizacion?: SortOrderInput | SortOrder
    medicos?: medicosOrderByWithRelationInput
  }

  export type horariosWhereUniqueInput = Prisma.AtLeast<{
    id_horario?: number
    AND?: horariosWhereInput | horariosWhereInput[]
    OR?: horariosWhereInput[]
    NOT?: horariosWhereInput | horariosWhereInput[]
    id_medico?: IntFilter<"horarios"> | number
    dia_semana?: StringFilter<"horarios"> | string
    hora_inicio?: DateTimeFilter<"horarios"> | Date | string
    hora_fin?: DateTimeFilter<"horarios"> | Date | string
    estado_auditoria?: StringNullableFilter<"horarios"> | string | null
    fecha_creacion?: DateTimeNullableFilter<"horarios"> | Date | string | null
    fecha_actualizacion?: DateTimeNullableFilter<"horarios"> | Date | string | null
    medicos?: XOR<MedicosScalarRelationFilter, medicosWhereInput>
  }, "id_horario">

  export type horariosOrderByWithAggregationInput = {
    id_horario?: SortOrder
    id_medico?: SortOrder
    dia_semana?: SortOrder
    hora_inicio?: SortOrder
    hora_fin?: SortOrder
    estado_auditoria?: SortOrderInput | SortOrder
    fecha_creacion?: SortOrderInput | SortOrder
    fecha_actualizacion?: SortOrderInput | SortOrder
    _count?: horariosCountOrderByAggregateInput
    _avg?: horariosAvgOrderByAggregateInput
    _max?: horariosMaxOrderByAggregateInput
    _min?: horariosMinOrderByAggregateInput
    _sum?: horariosSumOrderByAggregateInput
  }

  export type horariosScalarWhereWithAggregatesInput = {
    AND?: horariosScalarWhereWithAggregatesInput | horariosScalarWhereWithAggregatesInput[]
    OR?: horariosScalarWhereWithAggregatesInput[]
    NOT?: horariosScalarWhereWithAggregatesInput | horariosScalarWhereWithAggregatesInput[]
    id_horario?: IntWithAggregatesFilter<"horarios"> | number
    id_medico?: IntWithAggregatesFilter<"horarios"> | number
    dia_semana?: StringWithAggregatesFilter<"horarios"> | string
    hora_inicio?: DateTimeWithAggregatesFilter<"horarios"> | Date | string
    hora_fin?: DateTimeWithAggregatesFilter<"horarios"> | Date | string
    estado_auditoria?: StringNullableWithAggregatesFilter<"horarios"> | string | null
    fecha_creacion?: DateTimeNullableWithAggregatesFilter<"horarios"> | Date | string | null
    fecha_actualizacion?: DateTimeNullableWithAggregatesFilter<"horarios"> | Date | string | null
  }

  export type medicosWhereInput = {
    AND?: medicosWhereInput | medicosWhereInput[]
    OR?: medicosWhereInput[]
    NOT?: medicosWhereInput | medicosWhereInput[]
    id_medico?: IntFilter<"medicos"> | number
    nombres?: StringFilter<"medicos"> | string
    apellidos?: StringFilter<"medicos"> | string
    correo?: StringNullableFilter<"medicos"> | string | null
    celular?: StringNullableFilter<"medicos"> | string | null
    id_especialidad?: IntFilter<"medicos"> | number
    estado_auditoria?: StringNullableFilter<"medicos"> | string | null
    fecha_creacion?: DateTimeNullableFilter<"medicos"> | Date | string | null
    fecha_actualizacion?: DateTimeNullableFilter<"medicos"> | Date | string | null
    citas?: CitasListRelationFilter
    horarios?: HorariosListRelationFilter
    especialidades?: XOR<EspecialidadesScalarRelationFilter, especialidadesWhereInput>
  }

  export type medicosOrderByWithRelationInput = {
    id_medico?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    correo?: SortOrderInput | SortOrder
    celular?: SortOrderInput | SortOrder
    id_especialidad?: SortOrder
    estado_auditoria?: SortOrderInput | SortOrder
    fecha_creacion?: SortOrderInput | SortOrder
    fecha_actualizacion?: SortOrderInput | SortOrder
    citas?: citasOrderByRelationAggregateInput
    horarios?: horariosOrderByRelationAggregateInput
    especialidades?: especialidadesOrderByWithRelationInput
  }

  export type medicosWhereUniqueInput = Prisma.AtLeast<{
    id_medico?: number
    AND?: medicosWhereInput | medicosWhereInput[]
    OR?: medicosWhereInput[]
    NOT?: medicosWhereInput | medicosWhereInput[]
    nombres?: StringFilter<"medicos"> | string
    apellidos?: StringFilter<"medicos"> | string
    correo?: StringNullableFilter<"medicos"> | string | null
    celular?: StringNullableFilter<"medicos"> | string | null
    id_especialidad?: IntFilter<"medicos"> | number
    estado_auditoria?: StringNullableFilter<"medicos"> | string | null
    fecha_creacion?: DateTimeNullableFilter<"medicos"> | Date | string | null
    fecha_actualizacion?: DateTimeNullableFilter<"medicos"> | Date | string | null
    citas?: CitasListRelationFilter
    horarios?: HorariosListRelationFilter
    especialidades?: XOR<EspecialidadesScalarRelationFilter, especialidadesWhereInput>
  }, "id_medico">

  export type medicosOrderByWithAggregationInput = {
    id_medico?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    correo?: SortOrderInput | SortOrder
    celular?: SortOrderInput | SortOrder
    id_especialidad?: SortOrder
    estado_auditoria?: SortOrderInput | SortOrder
    fecha_creacion?: SortOrderInput | SortOrder
    fecha_actualizacion?: SortOrderInput | SortOrder
    _count?: medicosCountOrderByAggregateInput
    _avg?: medicosAvgOrderByAggregateInput
    _max?: medicosMaxOrderByAggregateInput
    _min?: medicosMinOrderByAggregateInput
    _sum?: medicosSumOrderByAggregateInput
  }

  export type medicosScalarWhereWithAggregatesInput = {
    AND?: medicosScalarWhereWithAggregatesInput | medicosScalarWhereWithAggregatesInput[]
    OR?: medicosScalarWhereWithAggregatesInput[]
    NOT?: medicosScalarWhereWithAggregatesInput | medicosScalarWhereWithAggregatesInput[]
    id_medico?: IntWithAggregatesFilter<"medicos"> | number
    nombres?: StringWithAggregatesFilter<"medicos"> | string
    apellidos?: StringWithAggregatesFilter<"medicos"> | string
    correo?: StringNullableWithAggregatesFilter<"medicos"> | string | null
    celular?: StringNullableWithAggregatesFilter<"medicos"> | string | null
    id_especialidad?: IntWithAggregatesFilter<"medicos"> | number
    estado_auditoria?: StringNullableWithAggregatesFilter<"medicos"> | string | null
    fecha_creacion?: DateTimeNullableWithAggregatesFilter<"medicos"> | Date | string | null
    fecha_actualizacion?: DateTimeNullableWithAggregatesFilter<"medicos"> | Date | string | null
  }

  export type pacientesWhereInput = {
    AND?: pacientesWhereInput | pacientesWhereInput[]
    OR?: pacientesWhereInput[]
    NOT?: pacientesWhereInput | pacientesWhereInput[]
    id_paciente?: IntFilter<"pacientes"> | number
    nombres?: StringFilter<"pacientes"> | string
    apellidos?: StringFilter<"pacientes"> | string
    edad?: IntNullableFilter<"pacientes"> | number | null
    fecha_nacimiento?: DateTimeNullableFilter<"pacientes"> | Date | string | null
    id_tipo_documento?: IntFilter<"pacientes"> | number
    numero_documento?: StringFilter<"pacientes"> | string
    direccion?: StringNullableFilter<"pacientes"> | string | null
    correo?: StringNullableFilter<"pacientes"> | string | null
    genero?: StringFilter<"pacientes"> | string
    estado_auditoria?: StringNullableFilter<"pacientes"> | string | null
    fecha_creacion?: DateTimeNullableFilter<"pacientes"> | Date | string | null
    fecha_actualizacion?: DateTimeNullableFilter<"pacientes"> | Date | string | null
    citas?: CitasListRelationFilter
    tipo_documentos?: XOR<Tipo_documentosScalarRelationFilter, tipo_documentosWhereInput>
  }

  export type pacientesOrderByWithRelationInput = {
    id_paciente?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    edad?: SortOrderInput | SortOrder
    fecha_nacimiento?: SortOrderInput | SortOrder
    id_tipo_documento?: SortOrder
    numero_documento?: SortOrder
    direccion?: SortOrderInput | SortOrder
    correo?: SortOrderInput | SortOrder
    genero?: SortOrder
    estado_auditoria?: SortOrderInput | SortOrder
    fecha_creacion?: SortOrderInput | SortOrder
    fecha_actualizacion?: SortOrderInput | SortOrder
    citas?: citasOrderByRelationAggregateInput
    tipo_documentos?: tipo_documentosOrderByWithRelationInput
  }

  export type pacientesWhereUniqueInput = Prisma.AtLeast<{
    id_paciente?: number
    numero_documento?: string
    AND?: pacientesWhereInput | pacientesWhereInput[]
    OR?: pacientesWhereInput[]
    NOT?: pacientesWhereInput | pacientesWhereInput[]
    nombres?: StringFilter<"pacientes"> | string
    apellidos?: StringFilter<"pacientes"> | string
    edad?: IntNullableFilter<"pacientes"> | number | null
    fecha_nacimiento?: DateTimeNullableFilter<"pacientes"> | Date | string | null
    id_tipo_documento?: IntFilter<"pacientes"> | number
    direccion?: StringNullableFilter<"pacientes"> | string | null
    correo?: StringNullableFilter<"pacientes"> | string | null
    genero?: StringFilter<"pacientes"> | string
    estado_auditoria?: StringNullableFilter<"pacientes"> | string | null
    fecha_creacion?: DateTimeNullableFilter<"pacientes"> | Date | string | null
    fecha_actualizacion?: DateTimeNullableFilter<"pacientes"> | Date | string | null
    citas?: CitasListRelationFilter
    tipo_documentos?: XOR<Tipo_documentosScalarRelationFilter, tipo_documentosWhereInput>
  }, "id_paciente" | "numero_documento">

  export type pacientesOrderByWithAggregationInput = {
    id_paciente?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    edad?: SortOrderInput | SortOrder
    fecha_nacimiento?: SortOrderInput | SortOrder
    id_tipo_documento?: SortOrder
    numero_documento?: SortOrder
    direccion?: SortOrderInput | SortOrder
    correo?: SortOrderInput | SortOrder
    genero?: SortOrder
    estado_auditoria?: SortOrderInput | SortOrder
    fecha_creacion?: SortOrderInput | SortOrder
    fecha_actualizacion?: SortOrderInput | SortOrder
    _count?: pacientesCountOrderByAggregateInput
    _avg?: pacientesAvgOrderByAggregateInput
    _max?: pacientesMaxOrderByAggregateInput
    _min?: pacientesMinOrderByAggregateInput
    _sum?: pacientesSumOrderByAggregateInput
  }

  export type pacientesScalarWhereWithAggregatesInput = {
    AND?: pacientesScalarWhereWithAggregatesInput | pacientesScalarWhereWithAggregatesInput[]
    OR?: pacientesScalarWhereWithAggregatesInput[]
    NOT?: pacientesScalarWhereWithAggregatesInput | pacientesScalarWhereWithAggregatesInput[]
    id_paciente?: IntWithAggregatesFilter<"pacientes"> | number
    nombres?: StringWithAggregatesFilter<"pacientes"> | string
    apellidos?: StringWithAggregatesFilter<"pacientes"> | string
    edad?: IntNullableWithAggregatesFilter<"pacientes"> | number | null
    fecha_nacimiento?: DateTimeNullableWithAggregatesFilter<"pacientes"> | Date | string | null
    id_tipo_documento?: IntWithAggregatesFilter<"pacientes"> | number
    numero_documento?: StringWithAggregatesFilter<"pacientes"> | string
    direccion?: StringNullableWithAggregatesFilter<"pacientes"> | string | null
    correo?: StringNullableWithAggregatesFilter<"pacientes"> | string | null
    genero?: StringWithAggregatesFilter<"pacientes"> | string
    estado_auditoria?: StringNullableWithAggregatesFilter<"pacientes"> | string | null
    fecha_creacion?: DateTimeNullableWithAggregatesFilter<"pacientes"> | Date | string | null
    fecha_actualizacion?: DateTimeNullableWithAggregatesFilter<"pacientes"> | Date | string | null
  }

  export type tipo_documentosCreateInput = {
    nombre: string
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
    pacientes?: pacientesCreateNestedManyWithoutTipo_documentosInput
  }

  export type tipo_documentosUncheckedCreateInput = {
    id_tipo_documento?: number
    nombre: string
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
    pacientes?: pacientesUncheckedCreateNestedManyWithoutTipo_documentosInput
  }

  export type tipo_documentosUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pacientes?: pacientesUpdateManyWithoutTipo_documentosNestedInput
  }

  export type tipo_documentosUncheckedUpdateInput = {
    id_tipo_documento?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pacientes?: pacientesUncheckedUpdateManyWithoutTipo_documentosNestedInput
  }

  export type tipo_documentosCreateManyInput = {
    id_tipo_documento?: number
    nombre: string
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
  }

  export type tipo_documentosUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tipo_documentosUncheckedUpdateManyInput = {
    id_tipo_documento?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type citasCreateInput = {
    fecha: Date | string
    hora: Date | string
    estado_cita?: string | null
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
    medicos: medicosCreateNestedOneWithoutCitasInput
    pacientes: pacientesCreateNestedOneWithoutCitasInput
  }

  export type citasUncheckedCreateInput = {
    id_cita?: number
    id_paciente: number
    id_medico: number
    fecha: Date | string
    hora: Date | string
    estado_cita?: string | null
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
  }

  export type citasUpdateInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_cita?: NullableStringFieldUpdateOperationsInput | string | null
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicos?: medicosUpdateOneRequiredWithoutCitasNestedInput
    pacientes?: pacientesUpdateOneRequiredWithoutCitasNestedInput
  }

  export type citasUncheckedUpdateInput = {
    id_cita?: IntFieldUpdateOperationsInput | number
    id_paciente?: IntFieldUpdateOperationsInput | number
    id_medico?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_cita?: NullableStringFieldUpdateOperationsInput | string | null
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type citasCreateManyInput = {
    id_cita?: number
    id_paciente: number
    id_medico: number
    fecha: Date | string
    hora: Date | string
    estado_cita?: string | null
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
  }

  export type citasUpdateManyMutationInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_cita?: NullableStringFieldUpdateOperationsInput | string | null
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type citasUncheckedUpdateManyInput = {
    id_cita?: IntFieldUpdateOperationsInput | number
    id_paciente?: IntFieldUpdateOperationsInput | number
    id_medico?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_cita?: NullableStringFieldUpdateOperationsInput | string | null
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type especialidadesCreateInput = {
    nombre: string
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
    medicos?: medicosCreateNestedManyWithoutEspecialidadesInput
  }

  export type especialidadesUncheckedCreateInput = {
    id_especialidad?: number
    nombre: string
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
    medicos?: medicosUncheckedCreateNestedManyWithoutEspecialidadesInput
  }

  export type especialidadesUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicos?: medicosUpdateManyWithoutEspecialidadesNestedInput
  }

  export type especialidadesUncheckedUpdateInput = {
    id_especialidad?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicos?: medicosUncheckedUpdateManyWithoutEspecialidadesNestedInput
  }

  export type especialidadesCreateManyInput = {
    id_especialidad?: number
    nombre: string
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
  }

  export type especialidadesUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type especialidadesUncheckedUpdateManyInput = {
    id_especialidad?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type horariosCreateInput = {
    dia_semana: string
    hora_inicio: Date | string
    hora_fin: Date | string
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
    medicos: medicosCreateNestedOneWithoutHorariosInput
  }

  export type horariosUncheckedCreateInput = {
    id_horario?: number
    id_medico: number
    dia_semana: string
    hora_inicio: Date | string
    hora_fin: Date | string
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
  }

  export type horariosUpdateInput = {
    dia_semana?: StringFieldUpdateOperationsInput | string
    hora_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    hora_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicos?: medicosUpdateOneRequiredWithoutHorariosNestedInput
  }

  export type horariosUncheckedUpdateInput = {
    id_horario?: IntFieldUpdateOperationsInput | number
    id_medico?: IntFieldUpdateOperationsInput | number
    dia_semana?: StringFieldUpdateOperationsInput | string
    hora_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    hora_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type horariosCreateManyInput = {
    id_horario?: number
    id_medico: number
    dia_semana: string
    hora_inicio: Date | string
    hora_fin: Date | string
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
  }

  export type horariosUpdateManyMutationInput = {
    dia_semana?: StringFieldUpdateOperationsInput | string
    hora_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    hora_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type horariosUncheckedUpdateManyInput = {
    id_horario?: IntFieldUpdateOperationsInput | number
    id_medico?: IntFieldUpdateOperationsInput | number
    dia_semana?: StringFieldUpdateOperationsInput | string
    hora_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    hora_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type medicosCreateInput = {
    nombres: string
    apellidos: string
    correo?: string | null
    celular?: string | null
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
    citas?: citasCreateNestedManyWithoutMedicosInput
    horarios?: horariosCreateNestedManyWithoutMedicosInput
    especialidades: especialidadesCreateNestedOneWithoutMedicosInput
  }

  export type medicosUncheckedCreateInput = {
    id_medico?: number
    nombres: string
    apellidos: string
    correo?: string | null
    celular?: string | null
    id_especialidad: number
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
    citas?: citasUncheckedCreateNestedManyWithoutMedicosInput
    horarios?: horariosUncheckedCreateNestedManyWithoutMedicosInput
  }

  export type medicosUpdateInput = {
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    citas?: citasUpdateManyWithoutMedicosNestedInput
    horarios?: horariosUpdateManyWithoutMedicosNestedInput
    especialidades?: especialidadesUpdateOneRequiredWithoutMedicosNestedInput
  }

  export type medicosUncheckedUpdateInput = {
    id_medico?: IntFieldUpdateOperationsInput | number
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    id_especialidad?: IntFieldUpdateOperationsInput | number
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    citas?: citasUncheckedUpdateManyWithoutMedicosNestedInput
    horarios?: horariosUncheckedUpdateManyWithoutMedicosNestedInput
  }

  export type medicosCreateManyInput = {
    id_medico?: number
    nombres: string
    apellidos: string
    correo?: string | null
    celular?: string | null
    id_especialidad: number
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
  }

  export type medicosUpdateManyMutationInput = {
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type medicosUncheckedUpdateManyInput = {
    id_medico?: IntFieldUpdateOperationsInput | number
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    id_especialidad?: IntFieldUpdateOperationsInput | number
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pacientesCreateInput = {
    nombres: string
    apellidos: string
    edad?: number | null
    fecha_nacimiento?: Date | string | null
    numero_documento: string
    direccion?: string | null
    correo?: string | null
    genero: string
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
    citas?: citasCreateNestedManyWithoutPacientesInput
    tipo_documentos: tipo_documentosCreateNestedOneWithoutPacientesInput
  }

  export type pacientesUncheckedCreateInput = {
    id_paciente?: number
    nombres: string
    apellidos: string
    edad?: number | null
    fecha_nacimiento?: Date | string | null
    id_tipo_documento: number
    numero_documento: string
    direccion?: string | null
    correo?: string | null
    genero: string
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
    citas?: citasUncheckedCreateNestedManyWithoutPacientesInput
  }

  export type pacientesUpdateInput = {
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numero_documento?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    citas?: citasUpdateManyWithoutPacientesNestedInput
    tipo_documentos?: tipo_documentosUpdateOneRequiredWithoutPacientesNestedInput
  }

  export type pacientesUncheckedUpdateInput = {
    id_paciente?: IntFieldUpdateOperationsInput | number
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_tipo_documento?: IntFieldUpdateOperationsInput | number
    numero_documento?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    citas?: citasUncheckedUpdateManyWithoutPacientesNestedInput
  }

  export type pacientesCreateManyInput = {
    id_paciente?: number
    nombres: string
    apellidos: string
    edad?: number | null
    fecha_nacimiento?: Date | string | null
    id_tipo_documento: number
    numero_documento: string
    direccion?: string | null
    correo?: string | null
    genero: string
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
  }

  export type pacientesUpdateManyMutationInput = {
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numero_documento?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pacientesUncheckedUpdateManyInput = {
    id_paciente?: IntFieldUpdateOperationsInput | number
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_tipo_documento?: IntFieldUpdateOperationsInput | number
    numero_documento?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type PacientesListRelationFilter = {
    every?: pacientesWhereInput
    some?: pacientesWhereInput
    none?: pacientesWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type pacientesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tipo_documentosCountOrderByAggregateInput = {
    id_tipo_documento?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_actualizacion?: SortOrder
  }

  export type tipo_documentosAvgOrderByAggregateInput = {
    id_tipo_documento?: SortOrder
  }

  export type tipo_documentosMaxOrderByAggregateInput = {
    id_tipo_documento?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_actualizacion?: SortOrder
  }

  export type tipo_documentosMinOrderByAggregateInput = {
    id_tipo_documento?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_actualizacion?: SortOrder
  }

  export type tipo_documentosSumOrderByAggregateInput = {
    id_tipo_documento?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type MedicosScalarRelationFilter = {
    is?: medicosWhereInput
    isNot?: medicosWhereInput
  }

  export type PacientesScalarRelationFilter = {
    is?: pacientesWhereInput
    isNot?: pacientesWhereInput
  }

  export type citasCountOrderByAggregateInput = {
    id_cita?: SortOrder
    id_paciente?: SortOrder
    id_medico?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    estado_cita?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_actualizacion?: SortOrder
  }

  export type citasAvgOrderByAggregateInput = {
    id_cita?: SortOrder
    id_paciente?: SortOrder
    id_medico?: SortOrder
  }

  export type citasMaxOrderByAggregateInput = {
    id_cita?: SortOrder
    id_paciente?: SortOrder
    id_medico?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    estado_cita?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_actualizacion?: SortOrder
  }

  export type citasMinOrderByAggregateInput = {
    id_cita?: SortOrder
    id_paciente?: SortOrder
    id_medico?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    estado_cita?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_actualizacion?: SortOrder
  }

  export type citasSumOrderByAggregateInput = {
    id_cita?: SortOrder
    id_paciente?: SortOrder
    id_medico?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type MedicosListRelationFilter = {
    every?: medicosWhereInput
    some?: medicosWhereInput
    none?: medicosWhereInput
  }

  export type medicosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type especialidadesCountOrderByAggregateInput = {
    id_especialidad?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_actualizacion?: SortOrder
  }

  export type especialidadesAvgOrderByAggregateInput = {
    id_especialidad?: SortOrder
  }

  export type especialidadesMaxOrderByAggregateInput = {
    id_especialidad?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_actualizacion?: SortOrder
  }

  export type especialidadesMinOrderByAggregateInput = {
    id_especialidad?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_actualizacion?: SortOrder
  }

  export type especialidadesSumOrderByAggregateInput = {
    id_especialidad?: SortOrder
  }

  export type horariosCountOrderByAggregateInput = {
    id_horario?: SortOrder
    id_medico?: SortOrder
    dia_semana?: SortOrder
    hora_inicio?: SortOrder
    hora_fin?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_actualizacion?: SortOrder
  }

  export type horariosAvgOrderByAggregateInput = {
    id_horario?: SortOrder
    id_medico?: SortOrder
  }

  export type horariosMaxOrderByAggregateInput = {
    id_horario?: SortOrder
    id_medico?: SortOrder
    dia_semana?: SortOrder
    hora_inicio?: SortOrder
    hora_fin?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_actualizacion?: SortOrder
  }

  export type horariosMinOrderByAggregateInput = {
    id_horario?: SortOrder
    id_medico?: SortOrder
    dia_semana?: SortOrder
    hora_inicio?: SortOrder
    hora_fin?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_actualizacion?: SortOrder
  }

  export type horariosSumOrderByAggregateInput = {
    id_horario?: SortOrder
    id_medico?: SortOrder
  }

  export type CitasListRelationFilter = {
    every?: citasWhereInput
    some?: citasWhereInput
    none?: citasWhereInput
  }

  export type HorariosListRelationFilter = {
    every?: horariosWhereInput
    some?: horariosWhereInput
    none?: horariosWhereInput
  }

  export type EspecialidadesScalarRelationFilter = {
    is?: especialidadesWhereInput
    isNot?: especialidadesWhereInput
  }

  export type citasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type horariosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type medicosCountOrderByAggregateInput = {
    id_medico?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    correo?: SortOrder
    celular?: SortOrder
    id_especialidad?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_actualizacion?: SortOrder
  }

  export type medicosAvgOrderByAggregateInput = {
    id_medico?: SortOrder
    id_especialidad?: SortOrder
  }

  export type medicosMaxOrderByAggregateInput = {
    id_medico?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    correo?: SortOrder
    celular?: SortOrder
    id_especialidad?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_actualizacion?: SortOrder
  }

  export type medicosMinOrderByAggregateInput = {
    id_medico?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    correo?: SortOrder
    celular?: SortOrder
    id_especialidad?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_actualizacion?: SortOrder
  }

  export type medicosSumOrderByAggregateInput = {
    id_medico?: SortOrder
    id_especialidad?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type Tipo_documentosScalarRelationFilter = {
    is?: tipo_documentosWhereInput
    isNot?: tipo_documentosWhereInput
  }

  export type pacientesCountOrderByAggregateInput = {
    id_paciente?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    edad?: SortOrder
    fecha_nacimiento?: SortOrder
    id_tipo_documento?: SortOrder
    numero_documento?: SortOrder
    direccion?: SortOrder
    correo?: SortOrder
    genero?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_actualizacion?: SortOrder
  }

  export type pacientesAvgOrderByAggregateInput = {
    id_paciente?: SortOrder
    edad?: SortOrder
    id_tipo_documento?: SortOrder
  }

  export type pacientesMaxOrderByAggregateInput = {
    id_paciente?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    edad?: SortOrder
    fecha_nacimiento?: SortOrder
    id_tipo_documento?: SortOrder
    numero_documento?: SortOrder
    direccion?: SortOrder
    correo?: SortOrder
    genero?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_actualizacion?: SortOrder
  }

  export type pacientesMinOrderByAggregateInput = {
    id_paciente?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    edad?: SortOrder
    fecha_nacimiento?: SortOrder
    id_tipo_documento?: SortOrder
    numero_documento?: SortOrder
    direccion?: SortOrder
    correo?: SortOrder
    genero?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_actualizacion?: SortOrder
  }

  export type pacientesSumOrderByAggregateInput = {
    id_paciente?: SortOrder
    edad?: SortOrder
    id_tipo_documento?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type pacientesCreateNestedManyWithoutTipo_documentosInput = {
    create?: XOR<pacientesCreateWithoutTipo_documentosInput, pacientesUncheckedCreateWithoutTipo_documentosInput> | pacientesCreateWithoutTipo_documentosInput[] | pacientesUncheckedCreateWithoutTipo_documentosInput[]
    connectOrCreate?: pacientesCreateOrConnectWithoutTipo_documentosInput | pacientesCreateOrConnectWithoutTipo_documentosInput[]
    createMany?: pacientesCreateManyTipo_documentosInputEnvelope
    connect?: pacientesWhereUniqueInput | pacientesWhereUniqueInput[]
  }

  export type pacientesUncheckedCreateNestedManyWithoutTipo_documentosInput = {
    create?: XOR<pacientesCreateWithoutTipo_documentosInput, pacientesUncheckedCreateWithoutTipo_documentosInput> | pacientesCreateWithoutTipo_documentosInput[] | pacientesUncheckedCreateWithoutTipo_documentosInput[]
    connectOrCreate?: pacientesCreateOrConnectWithoutTipo_documentosInput | pacientesCreateOrConnectWithoutTipo_documentosInput[]
    createMany?: pacientesCreateManyTipo_documentosInputEnvelope
    connect?: pacientesWhereUniqueInput | pacientesWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type pacientesUpdateManyWithoutTipo_documentosNestedInput = {
    create?: XOR<pacientesCreateWithoutTipo_documentosInput, pacientesUncheckedCreateWithoutTipo_documentosInput> | pacientesCreateWithoutTipo_documentosInput[] | pacientesUncheckedCreateWithoutTipo_documentosInput[]
    connectOrCreate?: pacientesCreateOrConnectWithoutTipo_documentosInput | pacientesCreateOrConnectWithoutTipo_documentosInput[]
    upsert?: pacientesUpsertWithWhereUniqueWithoutTipo_documentosInput | pacientesUpsertWithWhereUniqueWithoutTipo_documentosInput[]
    createMany?: pacientesCreateManyTipo_documentosInputEnvelope
    set?: pacientesWhereUniqueInput | pacientesWhereUniqueInput[]
    disconnect?: pacientesWhereUniqueInput | pacientesWhereUniqueInput[]
    delete?: pacientesWhereUniqueInput | pacientesWhereUniqueInput[]
    connect?: pacientesWhereUniqueInput | pacientesWhereUniqueInput[]
    update?: pacientesUpdateWithWhereUniqueWithoutTipo_documentosInput | pacientesUpdateWithWhereUniqueWithoutTipo_documentosInput[]
    updateMany?: pacientesUpdateManyWithWhereWithoutTipo_documentosInput | pacientesUpdateManyWithWhereWithoutTipo_documentosInput[]
    deleteMany?: pacientesScalarWhereInput | pacientesScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type pacientesUncheckedUpdateManyWithoutTipo_documentosNestedInput = {
    create?: XOR<pacientesCreateWithoutTipo_documentosInput, pacientesUncheckedCreateWithoutTipo_documentosInput> | pacientesCreateWithoutTipo_documentosInput[] | pacientesUncheckedCreateWithoutTipo_documentosInput[]
    connectOrCreate?: pacientesCreateOrConnectWithoutTipo_documentosInput | pacientesCreateOrConnectWithoutTipo_documentosInput[]
    upsert?: pacientesUpsertWithWhereUniqueWithoutTipo_documentosInput | pacientesUpsertWithWhereUniqueWithoutTipo_documentosInput[]
    createMany?: pacientesCreateManyTipo_documentosInputEnvelope
    set?: pacientesWhereUniqueInput | pacientesWhereUniqueInput[]
    disconnect?: pacientesWhereUniqueInput | pacientesWhereUniqueInput[]
    delete?: pacientesWhereUniqueInput | pacientesWhereUniqueInput[]
    connect?: pacientesWhereUniqueInput | pacientesWhereUniqueInput[]
    update?: pacientesUpdateWithWhereUniqueWithoutTipo_documentosInput | pacientesUpdateWithWhereUniqueWithoutTipo_documentosInput[]
    updateMany?: pacientesUpdateManyWithWhereWithoutTipo_documentosInput | pacientesUpdateManyWithWhereWithoutTipo_documentosInput[]
    deleteMany?: pacientesScalarWhereInput | pacientesScalarWhereInput[]
  }

  export type medicosCreateNestedOneWithoutCitasInput = {
    create?: XOR<medicosCreateWithoutCitasInput, medicosUncheckedCreateWithoutCitasInput>
    connectOrCreate?: medicosCreateOrConnectWithoutCitasInput
    connect?: medicosWhereUniqueInput
  }

  export type pacientesCreateNestedOneWithoutCitasInput = {
    create?: XOR<pacientesCreateWithoutCitasInput, pacientesUncheckedCreateWithoutCitasInput>
    connectOrCreate?: pacientesCreateOrConnectWithoutCitasInput
    connect?: pacientesWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type medicosUpdateOneRequiredWithoutCitasNestedInput = {
    create?: XOR<medicosCreateWithoutCitasInput, medicosUncheckedCreateWithoutCitasInput>
    connectOrCreate?: medicosCreateOrConnectWithoutCitasInput
    upsert?: medicosUpsertWithoutCitasInput
    connect?: medicosWhereUniqueInput
    update?: XOR<XOR<medicosUpdateToOneWithWhereWithoutCitasInput, medicosUpdateWithoutCitasInput>, medicosUncheckedUpdateWithoutCitasInput>
  }

  export type pacientesUpdateOneRequiredWithoutCitasNestedInput = {
    create?: XOR<pacientesCreateWithoutCitasInput, pacientesUncheckedCreateWithoutCitasInput>
    connectOrCreate?: pacientesCreateOrConnectWithoutCitasInput
    upsert?: pacientesUpsertWithoutCitasInput
    connect?: pacientesWhereUniqueInput
    update?: XOR<XOR<pacientesUpdateToOneWithWhereWithoutCitasInput, pacientesUpdateWithoutCitasInput>, pacientesUncheckedUpdateWithoutCitasInput>
  }

  export type medicosCreateNestedManyWithoutEspecialidadesInput = {
    create?: XOR<medicosCreateWithoutEspecialidadesInput, medicosUncheckedCreateWithoutEspecialidadesInput> | medicosCreateWithoutEspecialidadesInput[] | medicosUncheckedCreateWithoutEspecialidadesInput[]
    connectOrCreate?: medicosCreateOrConnectWithoutEspecialidadesInput | medicosCreateOrConnectWithoutEspecialidadesInput[]
    createMany?: medicosCreateManyEspecialidadesInputEnvelope
    connect?: medicosWhereUniqueInput | medicosWhereUniqueInput[]
  }

  export type medicosUncheckedCreateNestedManyWithoutEspecialidadesInput = {
    create?: XOR<medicosCreateWithoutEspecialidadesInput, medicosUncheckedCreateWithoutEspecialidadesInput> | medicosCreateWithoutEspecialidadesInput[] | medicosUncheckedCreateWithoutEspecialidadesInput[]
    connectOrCreate?: medicosCreateOrConnectWithoutEspecialidadesInput | medicosCreateOrConnectWithoutEspecialidadesInput[]
    createMany?: medicosCreateManyEspecialidadesInputEnvelope
    connect?: medicosWhereUniqueInput | medicosWhereUniqueInput[]
  }

  export type medicosUpdateManyWithoutEspecialidadesNestedInput = {
    create?: XOR<medicosCreateWithoutEspecialidadesInput, medicosUncheckedCreateWithoutEspecialidadesInput> | medicosCreateWithoutEspecialidadesInput[] | medicosUncheckedCreateWithoutEspecialidadesInput[]
    connectOrCreate?: medicosCreateOrConnectWithoutEspecialidadesInput | medicosCreateOrConnectWithoutEspecialidadesInput[]
    upsert?: medicosUpsertWithWhereUniqueWithoutEspecialidadesInput | medicosUpsertWithWhereUniqueWithoutEspecialidadesInput[]
    createMany?: medicosCreateManyEspecialidadesInputEnvelope
    set?: medicosWhereUniqueInput | medicosWhereUniqueInput[]
    disconnect?: medicosWhereUniqueInput | medicosWhereUniqueInput[]
    delete?: medicosWhereUniqueInput | medicosWhereUniqueInput[]
    connect?: medicosWhereUniqueInput | medicosWhereUniqueInput[]
    update?: medicosUpdateWithWhereUniqueWithoutEspecialidadesInput | medicosUpdateWithWhereUniqueWithoutEspecialidadesInput[]
    updateMany?: medicosUpdateManyWithWhereWithoutEspecialidadesInput | medicosUpdateManyWithWhereWithoutEspecialidadesInput[]
    deleteMany?: medicosScalarWhereInput | medicosScalarWhereInput[]
  }

  export type medicosUncheckedUpdateManyWithoutEspecialidadesNestedInput = {
    create?: XOR<medicosCreateWithoutEspecialidadesInput, medicosUncheckedCreateWithoutEspecialidadesInput> | medicosCreateWithoutEspecialidadesInput[] | medicosUncheckedCreateWithoutEspecialidadesInput[]
    connectOrCreate?: medicosCreateOrConnectWithoutEspecialidadesInput | medicosCreateOrConnectWithoutEspecialidadesInput[]
    upsert?: medicosUpsertWithWhereUniqueWithoutEspecialidadesInput | medicosUpsertWithWhereUniqueWithoutEspecialidadesInput[]
    createMany?: medicosCreateManyEspecialidadesInputEnvelope
    set?: medicosWhereUniqueInput | medicosWhereUniqueInput[]
    disconnect?: medicosWhereUniqueInput | medicosWhereUniqueInput[]
    delete?: medicosWhereUniqueInput | medicosWhereUniqueInput[]
    connect?: medicosWhereUniqueInput | medicosWhereUniqueInput[]
    update?: medicosUpdateWithWhereUniqueWithoutEspecialidadesInput | medicosUpdateWithWhereUniqueWithoutEspecialidadesInput[]
    updateMany?: medicosUpdateManyWithWhereWithoutEspecialidadesInput | medicosUpdateManyWithWhereWithoutEspecialidadesInput[]
    deleteMany?: medicosScalarWhereInput | medicosScalarWhereInput[]
  }

  export type medicosCreateNestedOneWithoutHorariosInput = {
    create?: XOR<medicosCreateWithoutHorariosInput, medicosUncheckedCreateWithoutHorariosInput>
    connectOrCreate?: medicosCreateOrConnectWithoutHorariosInput
    connect?: medicosWhereUniqueInput
  }

  export type medicosUpdateOneRequiredWithoutHorariosNestedInput = {
    create?: XOR<medicosCreateWithoutHorariosInput, medicosUncheckedCreateWithoutHorariosInput>
    connectOrCreate?: medicosCreateOrConnectWithoutHorariosInput
    upsert?: medicosUpsertWithoutHorariosInput
    connect?: medicosWhereUniqueInput
    update?: XOR<XOR<medicosUpdateToOneWithWhereWithoutHorariosInput, medicosUpdateWithoutHorariosInput>, medicosUncheckedUpdateWithoutHorariosInput>
  }

  export type citasCreateNestedManyWithoutMedicosInput = {
    create?: XOR<citasCreateWithoutMedicosInput, citasUncheckedCreateWithoutMedicosInput> | citasCreateWithoutMedicosInput[] | citasUncheckedCreateWithoutMedicosInput[]
    connectOrCreate?: citasCreateOrConnectWithoutMedicosInput | citasCreateOrConnectWithoutMedicosInput[]
    createMany?: citasCreateManyMedicosInputEnvelope
    connect?: citasWhereUniqueInput | citasWhereUniqueInput[]
  }

  export type horariosCreateNestedManyWithoutMedicosInput = {
    create?: XOR<horariosCreateWithoutMedicosInput, horariosUncheckedCreateWithoutMedicosInput> | horariosCreateWithoutMedicosInput[] | horariosUncheckedCreateWithoutMedicosInput[]
    connectOrCreate?: horariosCreateOrConnectWithoutMedicosInput | horariosCreateOrConnectWithoutMedicosInput[]
    createMany?: horariosCreateManyMedicosInputEnvelope
    connect?: horariosWhereUniqueInput | horariosWhereUniqueInput[]
  }

  export type especialidadesCreateNestedOneWithoutMedicosInput = {
    create?: XOR<especialidadesCreateWithoutMedicosInput, especialidadesUncheckedCreateWithoutMedicosInput>
    connectOrCreate?: especialidadesCreateOrConnectWithoutMedicosInput
    connect?: especialidadesWhereUniqueInput
  }

  export type citasUncheckedCreateNestedManyWithoutMedicosInput = {
    create?: XOR<citasCreateWithoutMedicosInput, citasUncheckedCreateWithoutMedicosInput> | citasCreateWithoutMedicosInput[] | citasUncheckedCreateWithoutMedicosInput[]
    connectOrCreate?: citasCreateOrConnectWithoutMedicosInput | citasCreateOrConnectWithoutMedicosInput[]
    createMany?: citasCreateManyMedicosInputEnvelope
    connect?: citasWhereUniqueInput | citasWhereUniqueInput[]
  }

  export type horariosUncheckedCreateNestedManyWithoutMedicosInput = {
    create?: XOR<horariosCreateWithoutMedicosInput, horariosUncheckedCreateWithoutMedicosInput> | horariosCreateWithoutMedicosInput[] | horariosUncheckedCreateWithoutMedicosInput[]
    connectOrCreate?: horariosCreateOrConnectWithoutMedicosInput | horariosCreateOrConnectWithoutMedicosInput[]
    createMany?: horariosCreateManyMedicosInputEnvelope
    connect?: horariosWhereUniqueInput | horariosWhereUniqueInput[]
  }

  export type citasUpdateManyWithoutMedicosNestedInput = {
    create?: XOR<citasCreateWithoutMedicosInput, citasUncheckedCreateWithoutMedicosInput> | citasCreateWithoutMedicosInput[] | citasUncheckedCreateWithoutMedicosInput[]
    connectOrCreate?: citasCreateOrConnectWithoutMedicosInput | citasCreateOrConnectWithoutMedicosInput[]
    upsert?: citasUpsertWithWhereUniqueWithoutMedicosInput | citasUpsertWithWhereUniqueWithoutMedicosInput[]
    createMany?: citasCreateManyMedicosInputEnvelope
    set?: citasWhereUniqueInput | citasWhereUniqueInput[]
    disconnect?: citasWhereUniqueInput | citasWhereUniqueInput[]
    delete?: citasWhereUniqueInput | citasWhereUniqueInput[]
    connect?: citasWhereUniqueInput | citasWhereUniqueInput[]
    update?: citasUpdateWithWhereUniqueWithoutMedicosInput | citasUpdateWithWhereUniqueWithoutMedicosInput[]
    updateMany?: citasUpdateManyWithWhereWithoutMedicosInput | citasUpdateManyWithWhereWithoutMedicosInput[]
    deleteMany?: citasScalarWhereInput | citasScalarWhereInput[]
  }

  export type horariosUpdateManyWithoutMedicosNestedInput = {
    create?: XOR<horariosCreateWithoutMedicosInput, horariosUncheckedCreateWithoutMedicosInput> | horariosCreateWithoutMedicosInput[] | horariosUncheckedCreateWithoutMedicosInput[]
    connectOrCreate?: horariosCreateOrConnectWithoutMedicosInput | horariosCreateOrConnectWithoutMedicosInput[]
    upsert?: horariosUpsertWithWhereUniqueWithoutMedicosInput | horariosUpsertWithWhereUniqueWithoutMedicosInput[]
    createMany?: horariosCreateManyMedicosInputEnvelope
    set?: horariosWhereUniqueInput | horariosWhereUniqueInput[]
    disconnect?: horariosWhereUniqueInput | horariosWhereUniqueInput[]
    delete?: horariosWhereUniqueInput | horariosWhereUniqueInput[]
    connect?: horariosWhereUniqueInput | horariosWhereUniqueInput[]
    update?: horariosUpdateWithWhereUniqueWithoutMedicosInput | horariosUpdateWithWhereUniqueWithoutMedicosInput[]
    updateMany?: horariosUpdateManyWithWhereWithoutMedicosInput | horariosUpdateManyWithWhereWithoutMedicosInput[]
    deleteMany?: horariosScalarWhereInput | horariosScalarWhereInput[]
  }

  export type especialidadesUpdateOneRequiredWithoutMedicosNestedInput = {
    create?: XOR<especialidadesCreateWithoutMedicosInput, especialidadesUncheckedCreateWithoutMedicosInput>
    connectOrCreate?: especialidadesCreateOrConnectWithoutMedicosInput
    upsert?: especialidadesUpsertWithoutMedicosInput
    connect?: especialidadesWhereUniqueInput
    update?: XOR<XOR<especialidadesUpdateToOneWithWhereWithoutMedicosInput, especialidadesUpdateWithoutMedicosInput>, especialidadesUncheckedUpdateWithoutMedicosInput>
  }

  export type citasUncheckedUpdateManyWithoutMedicosNestedInput = {
    create?: XOR<citasCreateWithoutMedicosInput, citasUncheckedCreateWithoutMedicosInput> | citasCreateWithoutMedicosInput[] | citasUncheckedCreateWithoutMedicosInput[]
    connectOrCreate?: citasCreateOrConnectWithoutMedicosInput | citasCreateOrConnectWithoutMedicosInput[]
    upsert?: citasUpsertWithWhereUniqueWithoutMedicosInput | citasUpsertWithWhereUniqueWithoutMedicosInput[]
    createMany?: citasCreateManyMedicosInputEnvelope
    set?: citasWhereUniqueInput | citasWhereUniqueInput[]
    disconnect?: citasWhereUniqueInput | citasWhereUniqueInput[]
    delete?: citasWhereUniqueInput | citasWhereUniqueInput[]
    connect?: citasWhereUniqueInput | citasWhereUniqueInput[]
    update?: citasUpdateWithWhereUniqueWithoutMedicosInput | citasUpdateWithWhereUniqueWithoutMedicosInput[]
    updateMany?: citasUpdateManyWithWhereWithoutMedicosInput | citasUpdateManyWithWhereWithoutMedicosInput[]
    deleteMany?: citasScalarWhereInput | citasScalarWhereInput[]
  }

  export type horariosUncheckedUpdateManyWithoutMedicosNestedInput = {
    create?: XOR<horariosCreateWithoutMedicosInput, horariosUncheckedCreateWithoutMedicosInput> | horariosCreateWithoutMedicosInput[] | horariosUncheckedCreateWithoutMedicosInput[]
    connectOrCreate?: horariosCreateOrConnectWithoutMedicosInput | horariosCreateOrConnectWithoutMedicosInput[]
    upsert?: horariosUpsertWithWhereUniqueWithoutMedicosInput | horariosUpsertWithWhereUniqueWithoutMedicosInput[]
    createMany?: horariosCreateManyMedicosInputEnvelope
    set?: horariosWhereUniqueInput | horariosWhereUniqueInput[]
    disconnect?: horariosWhereUniqueInput | horariosWhereUniqueInput[]
    delete?: horariosWhereUniqueInput | horariosWhereUniqueInput[]
    connect?: horariosWhereUniqueInput | horariosWhereUniqueInput[]
    update?: horariosUpdateWithWhereUniqueWithoutMedicosInput | horariosUpdateWithWhereUniqueWithoutMedicosInput[]
    updateMany?: horariosUpdateManyWithWhereWithoutMedicosInput | horariosUpdateManyWithWhereWithoutMedicosInput[]
    deleteMany?: horariosScalarWhereInput | horariosScalarWhereInput[]
  }

  export type citasCreateNestedManyWithoutPacientesInput = {
    create?: XOR<citasCreateWithoutPacientesInput, citasUncheckedCreateWithoutPacientesInput> | citasCreateWithoutPacientesInput[] | citasUncheckedCreateWithoutPacientesInput[]
    connectOrCreate?: citasCreateOrConnectWithoutPacientesInput | citasCreateOrConnectWithoutPacientesInput[]
    createMany?: citasCreateManyPacientesInputEnvelope
    connect?: citasWhereUniqueInput | citasWhereUniqueInput[]
  }

  export type tipo_documentosCreateNestedOneWithoutPacientesInput = {
    create?: XOR<tipo_documentosCreateWithoutPacientesInput, tipo_documentosUncheckedCreateWithoutPacientesInput>
    connectOrCreate?: tipo_documentosCreateOrConnectWithoutPacientesInput
    connect?: tipo_documentosWhereUniqueInput
  }

  export type citasUncheckedCreateNestedManyWithoutPacientesInput = {
    create?: XOR<citasCreateWithoutPacientesInput, citasUncheckedCreateWithoutPacientesInput> | citasCreateWithoutPacientesInput[] | citasUncheckedCreateWithoutPacientesInput[]
    connectOrCreate?: citasCreateOrConnectWithoutPacientesInput | citasCreateOrConnectWithoutPacientesInput[]
    createMany?: citasCreateManyPacientesInputEnvelope
    connect?: citasWhereUniqueInput | citasWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type citasUpdateManyWithoutPacientesNestedInput = {
    create?: XOR<citasCreateWithoutPacientesInput, citasUncheckedCreateWithoutPacientesInput> | citasCreateWithoutPacientesInput[] | citasUncheckedCreateWithoutPacientesInput[]
    connectOrCreate?: citasCreateOrConnectWithoutPacientesInput | citasCreateOrConnectWithoutPacientesInput[]
    upsert?: citasUpsertWithWhereUniqueWithoutPacientesInput | citasUpsertWithWhereUniqueWithoutPacientesInput[]
    createMany?: citasCreateManyPacientesInputEnvelope
    set?: citasWhereUniqueInput | citasWhereUniqueInput[]
    disconnect?: citasWhereUniqueInput | citasWhereUniqueInput[]
    delete?: citasWhereUniqueInput | citasWhereUniqueInput[]
    connect?: citasWhereUniqueInput | citasWhereUniqueInput[]
    update?: citasUpdateWithWhereUniqueWithoutPacientesInput | citasUpdateWithWhereUniqueWithoutPacientesInput[]
    updateMany?: citasUpdateManyWithWhereWithoutPacientesInput | citasUpdateManyWithWhereWithoutPacientesInput[]
    deleteMany?: citasScalarWhereInput | citasScalarWhereInput[]
  }

  export type tipo_documentosUpdateOneRequiredWithoutPacientesNestedInput = {
    create?: XOR<tipo_documentosCreateWithoutPacientesInput, tipo_documentosUncheckedCreateWithoutPacientesInput>
    connectOrCreate?: tipo_documentosCreateOrConnectWithoutPacientesInput
    upsert?: tipo_documentosUpsertWithoutPacientesInput
    connect?: tipo_documentosWhereUniqueInput
    update?: XOR<XOR<tipo_documentosUpdateToOneWithWhereWithoutPacientesInput, tipo_documentosUpdateWithoutPacientesInput>, tipo_documentosUncheckedUpdateWithoutPacientesInput>
  }

  export type citasUncheckedUpdateManyWithoutPacientesNestedInput = {
    create?: XOR<citasCreateWithoutPacientesInput, citasUncheckedCreateWithoutPacientesInput> | citasCreateWithoutPacientesInput[] | citasUncheckedCreateWithoutPacientesInput[]
    connectOrCreate?: citasCreateOrConnectWithoutPacientesInput | citasCreateOrConnectWithoutPacientesInput[]
    upsert?: citasUpsertWithWhereUniqueWithoutPacientesInput | citasUpsertWithWhereUniqueWithoutPacientesInput[]
    createMany?: citasCreateManyPacientesInputEnvelope
    set?: citasWhereUniqueInput | citasWhereUniqueInput[]
    disconnect?: citasWhereUniqueInput | citasWhereUniqueInput[]
    delete?: citasWhereUniqueInput | citasWhereUniqueInput[]
    connect?: citasWhereUniqueInput | citasWhereUniqueInput[]
    update?: citasUpdateWithWhereUniqueWithoutPacientesInput | citasUpdateWithWhereUniqueWithoutPacientesInput[]
    updateMany?: citasUpdateManyWithWhereWithoutPacientesInput | citasUpdateManyWithWhereWithoutPacientesInput[]
    deleteMany?: citasScalarWhereInput | citasScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type pacientesCreateWithoutTipo_documentosInput = {
    nombres: string
    apellidos: string
    edad?: number | null
    fecha_nacimiento?: Date | string | null
    numero_documento: string
    direccion?: string | null
    correo?: string | null
    genero: string
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
    citas?: citasCreateNestedManyWithoutPacientesInput
  }

  export type pacientesUncheckedCreateWithoutTipo_documentosInput = {
    id_paciente?: number
    nombres: string
    apellidos: string
    edad?: number | null
    fecha_nacimiento?: Date | string | null
    numero_documento: string
    direccion?: string | null
    correo?: string | null
    genero: string
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
    citas?: citasUncheckedCreateNestedManyWithoutPacientesInput
  }

  export type pacientesCreateOrConnectWithoutTipo_documentosInput = {
    where: pacientesWhereUniqueInput
    create: XOR<pacientesCreateWithoutTipo_documentosInput, pacientesUncheckedCreateWithoutTipo_documentosInput>
  }

  export type pacientesCreateManyTipo_documentosInputEnvelope = {
    data: pacientesCreateManyTipo_documentosInput | pacientesCreateManyTipo_documentosInput[]
    skipDuplicates?: boolean
  }

  export type pacientesUpsertWithWhereUniqueWithoutTipo_documentosInput = {
    where: pacientesWhereUniqueInput
    update: XOR<pacientesUpdateWithoutTipo_documentosInput, pacientesUncheckedUpdateWithoutTipo_documentosInput>
    create: XOR<pacientesCreateWithoutTipo_documentosInput, pacientesUncheckedCreateWithoutTipo_documentosInput>
  }

  export type pacientesUpdateWithWhereUniqueWithoutTipo_documentosInput = {
    where: pacientesWhereUniqueInput
    data: XOR<pacientesUpdateWithoutTipo_documentosInput, pacientesUncheckedUpdateWithoutTipo_documentosInput>
  }

  export type pacientesUpdateManyWithWhereWithoutTipo_documentosInput = {
    where: pacientesScalarWhereInput
    data: XOR<pacientesUpdateManyMutationInput, pacientesUncheckedUpdateManyWithoutTipo_documentosInput>
  }

  export type pacientesScalarWhereInput = {
    AND?: pacientesScalarWhereInput | pacientesScalarWhereInput[]
    OR?: pacientesScalarWhereInput[]
    NOT?: pacientesScalarWhereInput | pacientesScalarWhereInput[]
    id_paciente?: IntFilter<"pacientes"> | number
    nombres?: StringFilter<"pacientes"> | string
    apellidos?: StringFilter<"pacientes"> | string
    edad?: IntNullableFilter<"pacientes"> | number | null
    fecha_nacimiento?: DateTimeNullableFilter<"pacientes"> | Date | string | null
    id_tipo_documento?: IntFilter<"pacientes"> | number
    numero_documento?: StringFilter<"pacientes"> | string
    direccion?: StringNullableFilter<"pacientes"> | string | null
    correo?: StringNullableFilter<"pacientes"> | string | null
    genero?: StringFilter<"pacientes"> | string
    estado_auditoria?: StringNullableFilter<"pacientes"> | string | null
    fecha_creacion?: DateTimeNullableFilter<"pacientes"> | Date | string | null
    fecha_actualizacion?: DateTimeNullableFilter<"pacientes"> | Date | string | null
  }

  export type medicosCreateWithoutCitasInput = {
    nombres: string
    apellidos: string
    correo?: string | null
    celular?: string | null
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
    horarios?: horariosCreateNestedManyWithoutMedicosInput
    especialidades: especialidadesCreateNestedOneWithoutMedicosInput
  }

  export type medicosUncheckedCreateWithoutCitasInput = {
    id_medico?: number
    nombres: string
    apellidos: string
    correo?: string | null
    celular?: string | null
    id_especialidad: number
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
    horarios?: horariosUncheckedCreateNestedManyWithoutMedicosInput
  }

  export type medicosCreateOrConnectWithoutCitasInput = {
    where: medicosWhereUniqueInput
    create: XOR<medicosCreateWithoutCitasInput, medicosUncheckedCreateWithoutCitasInput>
  }

  export type pacientesCreateWithoutCitasInput = {
    nombres: string
    apellidos: string
    edad?: number | null
    fecha_nacimiento?: Date | string | null
    numero_documento: string
    direccion?: string | null
    correo?: string | null
    genero: string
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
    tipo_documentos: tipo_documentosCreateNestedOneWithoutPacientesInput
  }

  export type pacientesUncheckedCreateWithoutCitasInput = {
    id_paciente?: number
    nombres: string
    apellidos: string
    edad?: number | null
    fecha_nacimiento?: Date | string | null
    id_tipo_documento: number
    numero_documento: string
    direccion?: string | null
    correo?: string | null
    genero: string
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
  }

  export type pacientesCreateOrConnectWithoutCitasInput = {
    where: pacientesWhereUniqueInput
    create: XOR<pacientesCreateWithoutCitasInput, pacientesUncheckedCreateWithoutCitasInput>
  }

  export type medicosUpsertWithoutCitasInput = {
    update: XOR<medicosUpdateWithoutCitasInput, medicosUncheckedUpdateWithoutCitasInput>
    create: XOR<medicosCreateWithoutCitasInput, medicosUncheckedCreateWithoutCitasInput>
    where?: medicosWhereInput
  }

  export type medicosUpdateToOneWithWhereWithoutCitasInput = {
    where?: medicosWhereInput
    data: XOR<medicosUpdateWithoutCitasInput, medicosUncheckedUpdateWithoutCitasInput>
  }

  export type medicosUpdateWithoutCitasInput = {
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horarios?: horariosUpdateManyWithoutMedicosNestedInput
    especialidades?: especialidadesUpdateOneRequiredWithoutMedicosNestedInput
  }

  export type medicosUncheckedUpdateWithoutCitasInput = {
    id_medico?: IntFieldUpdateOperationsInput | number
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    id_especialidad?: IntFieldUpdateOperationsInput | number
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horarios?: horariosUncheckedUpdateManyWithoutMedicosNestedInput
  }

  export type pacientesUpsertWithoutCitasInput = {
    update: XOR<pacientesUpdateWithoutCitasInput, pacientesUncheckedUpdateWithoutCitasInput>
    create: XOR<pacientesCreateWithoutCitasInput, pacientesUncheckedCreateWithoutCitasInput>
    where?: pacientesWhereInput
  }

  export type pacientesUpdateToOneWithWhereWithoutCitasInput = {
    where?: pacientesWhereInput
    data: XOR<pacientesUpdateWithoutCitasInput, pacientesUncheckedUpdateWithoutCitasInput>
  }

  export type pacientesUpdateWithoutCitasInput = {
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numero_documento?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipo_documentos?: tipo_documentosUpdateOneRequiredWithoutPacientesNestedInput
  }

  export type pacientesUncheckedUpdateWithoutCitasInput = {
    id_paciente?: IntFieldUpdateOperationsInput | number
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_tipo_documento?: IntFieldUpdateOperationsInput | number
    numero_documento?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type medicosCreateWithoutEspecialidadesInput = {
    nombres: string
    apellidos: string
    correo?: string | null
    celular?: string | null
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
    citas?: citasCreateNestedManyWithoutMedicosInput
    horarios?: horariosCreateNestedManyWithoutMedicosInput
  }

  export type medicosUncheckedCreateWithoutEspecialidadesInput = {
    id_medico?: number
    nombres: string
    apellidos: string
    correo?: string | null
    celular?: string | null
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
    citas?: citasUncheckedCreateNestedManyWithoutMedicosInput
    horarios?: horariosUncheckedCreateNestedManyWithoutMedicosInput
  }

  export type medicosCreateOrConnectWithoutEspecialidadesInput = {
    where: medicosWhereUniqueInput
    create: XOR<medicosCreateWithoutEspecialidadesInput, medicosUncheckedCreateWithoutEspecialidadesInput>
  }

  export type medicosCreateManyEspecialidadesInputEnvelope = {
    data: medicosCreateManyEspecialidadesInput | medicosCreateManyEspecialidadesInput[]
    skipDuplicates?: boolean
  }

  export type medicosUpsertWithWhereUniqueWithoutEspecialidadesInput = {
    where: medicosWhereUniqueInput
    update: XOR<medicosUpdateWithoutEspecialidadesInput, medicosUncheckedUpdateWithoutEspecialidadesInput>
    create: XOR<medicosCreateWithoutEspecialidadesInput, medicosUncheckedCreateWithoutEspecialidadesInput>
  }

  export type medicosUpdateWithWhereUniqueWithoutEspecialidadesInput = {
    where: medicosWhereUniqueInput
    data: XOR<medicosUpdateWithoutEspecialidadesInput, medicosUncheckedUpdateWithoutEspecialidadesInput>
  }

  export type medicosUpdateManyWithWhereWithoutEspecialidadesInput = {
    where: medicosScalarWhereInput
    data: XOR<medicosUpdateManyMutationInput, medicosUncheckedUpdateManyWithoutEspecialidadesInput>
  }

  export type medicosScalarWhereInput = {
    AND?: medicosScalarWhereInput | medicosScalarWhereInput[]
    OR?: medicosScalarWhereInput[]
    NOT?: medicosScalarWhereInput | medicosScalarWhereInput[]
    id_medico?: IntFilter<"medicos"> | number
    nombres?: StringFilter<"medicos"> | string
    apellidos?: StringFilter<"medicos"> | string
    correo?: StringNullableFilter<"medicos"> | string | null
    celular?: StringNullableFilter<"medicos"> | string | null
    id_especialidad?: IntFilter<"medicos"> | number
    estado_auditoria?: StringNullableFilter<"medicos"> | string | null
    fecha_creacion?: DateTimeNullableFilter<"medicos"> | Date | string | null
    fecha_actualizacion?: DateTimeNullableFilter<"medicos"> | Date | string | null
  }

  export type medicosCreateWithoutHorariosInput = {
    nombres: string
    apellidos: string
    correo?: string | null
    celular?: string | null
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
    citas?: citasCreateNestedManyWithoutMedicosInput
    especialidades: especialidadesCreateNestedOneWithoutMedicosInput
  }

  export type medicosUncheckedCreateWithoutHorariosInput = {
    id_medico?: number
    nombres: string
    apellidos: string
    correo?: string | null
    celular?: string | null
    id_especialidad: number
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
    citas?: citasUncheckedCreateNestedManyWithoutMedicosInput
  }

  export type medicosCreateOrConnectWithoutHorariosInput = {
    where: medicosWhereUniqueInput
    create: XOR<medicosCreateWithoutHorariosInput, medicosUncheckedCreateWithoutHorariosInput>
  }

  export type medicosUpsertWithoutHorariosInput = {
    update: XOR<medicosUpdateWithoutHorariosInput, medicosUncheckedUpdateWithoutHorariosInput>
    create: XOR<medicosCreateWithoutHorariosInput, medicosUncheckedCreateWithoutHorariosInput>
    where?: medicosWhereInput
  }

  export type medicosUpdateToOneWithWhereWithoutHorariosInput = {
    where?: medicosWhereInput
    data: XOR<medicosUpdateWithoutHorariosInput, medicosUncheckedUpdateWithoutHorariosInput>
  }

  export type medicosUpdateWithoutHorariosInput = {
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    citas?: citasUpdateManyWithoutMedicosNestedInput
    especialidades?: especialidadesUpdateOneRequiredWithoutMedicosNestedInput
  }

  export type medicosUncheckedUpdateWithoutHorariosInput = {
    id_medico?: IntFieldUpdateOperationsInput | number
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    id_especialidad?: IntFieldUpdateOperationsInput | number
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    citas?: citasUncheckedUpdateManyWithoutMedicosNestedInput
  }

  export type citasCreateWithoutMedicosInput = {
    fecha: Date | string
    hora: Date | string
    estado_cita?: string | null
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
    pacientes: pacientesCreateNestedOneWithoutCitasInput
  }

  export type citasUncheckedCreateWithoutMedicosInput = {
    id_cita?: number
    id_paciente: number
    fecha: Date | string
    hora: Date | string
    estado_cita?: string | null
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
  }

  export type citasCreateOrConnectWithoutMedicosInput = {
    where: citasWhereUniqueInput
    create: XOR<citasCreateWithoutMedicosInput, citasUncheckedCreateWithoutMedicosInput>
  }

  export type citasCreateManyMedicosInputEnvelope = {
    data: citasCreateManyMedicosInput | citasCreateManyMedicosInput[]
    skipDuplicates?: boolean
  }

  export type horariosCreateWithoutMedicosInput = {
    dia_semana: string
    hora_inicio: Date | string
    hora_fin: Date | string
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
  }

  export type horariosUncheckedCreateWithoutMedicosInput = {
    id_horario?: number
    dia_semana: string
    hora_inicio: Date | string
    hora_fin: Date | string
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
  }

  export type horariosCreateOrConnectWithoutMedicosInput = {
    where: horariosWhereUniqueInput
    create: XOR<horariosCreateWithoutMedicosInput, horariosUncheckedCreateWithoutMedicosInput>
  }

  export type horariosCreateManyMedicosInputEnvelope = {
    data: horariosCreateManyMedicosInput | horariosCreateManyMedicosInput[]
    skipDuplicates?: boolean
  }

  export type especialidadesCreateWithoutMedicosInput = {
    nombre: string
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
  }

  export type especialidadesUncheckedCreateWithoutMedicosInput = {
    id_especialidad?: number
    nombre: string
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
  }

  export type especialidadesCreateOrConnectWithoutMedicosInput = {
    where: especialidadesWhereUniqueInput
    create: XOR<especialidadesCreateWithoutMedicosInput, especialidadesUncheckedCreateWithoutMedicosInput>
  }

  export type citasUpsertWithWhereUniqueWithoutMedicosInput = {
    where: citasWhereUniqueInput
    update: XOR<citasUpdateWithoutMedicosInput, citasUncheckedUpdateWithoutMedicosInput>
    create: XOR<citasCreateWithoutMedicosInput, citasUncheckedCreateWithoutMedicosInput>
  }

  export type citasUpdateWithWhereUniqueWithoutMedicosInput = {
    where: citasWhereUniqueInput
    data: XOR<citasUpdateWithoutMedicosInput, citasUncheckedUpdateWithoutMedicosInput>
  }

  export type citasUpdateManyWithWhereWithoutMedicosInput = {
    where: citasScalarWhereInput
    data: XOR<citasUpdateManyMutationInput, citasUncheckedUpdateManyWithoutMedicosInput>
  }

  export type citasScalarWhereInput = {
    AND?: citasScalarWhereInput | citasScalarWhereInput[]
    OR?: citasScalarWhereInput[]
    NOT?: citasScalarWhereInput | citasScalarWhereInput[]
    id_cita?: IntFilter<"citas"> | number
    id_paciente?: IntFilter<"citas"> | number
    id_medico?: IntFilter<"citas"> | number
    fecha?: DateTimeFilter<"citas"> | Date | string
    hora?: DateTimeFilter<"citas"> | Date | string
    estado_cita?: StringNullableFilter<"citas"> | string | null
    estado_auditoria?: StringNullableFilter<"citas"> | string | null
    fecha_creacion?: DateTimeNullableFilter<"citas"> | Date | string | null
    fecha_actualizacion?: DateTimeNullableFilter<"citas"> | Date | string | null
  }

  export type horariosUpsertWithWhereUniqueWithoutMedicosInput = {
    where: horariosWhereUniqueInput
    update: XOR<horariosUpdateWithoutMedicosInput, horariosUncheckedUpdateWithoutMedicosInput>
    create: XOR<horariosCreateWithoutMedicosInput, horariosUncheckedCreateWithoutMedicosInput>
  }

  export type horariosUpdateWithWhereUniqueWithoutMedicosInput = {
    where: horariosWhereUniqueInput
    data: XOR<horariosUpdateWithoutMedicosInput, horariosUncheckedUpdateWithoutMedicosInput>
  }

  export type horariosUpdateManyWithWhereWithoutMedicosInput = {
    where: horariosScalarWhereInput
    data: XOR<horariosUpdateManyMutationInput, horariosUncheckedUpdateManyWithoutMedicosInput>
  }

  export type horariosScalarWhereInput = {
    AND?: horariosScalarWhereInput | horariosScalarWhereInput[]
    OR?: horariosScalarWhereInput[]
    NOT?: horariosScalarWhereInput | horariosScalarWhereInput[]
    id_horario?: IntFilter<"horarios"> | number
    id_medico?: IntFilter<"horarios"> | number
    dia_semana?: StringFilter<"horarios"> | string
    hora_inicio?: DateTimeFilter<"horarios"> | Date | string
    hora_fin?: DateTimeFilter<"horarios"> | Date | string
    estado_auditoria?: StringNullableFilter<"horarios"> | string | null
    fecha_creacion?: DateTimeNullableFilter<"horarios"> | Date | string | null
    fecha_actualizacion?: DateTimeNullableFilter<"horarios"> | Date | string | null
  }

  export type especialidadesUpsertWithoutMedicosInput = {
    update: XOR<especialidadesUpdateWithoutMedicosInput, especialidadesUncheckedUpdateWithoutMedicosInput>
    create: XOR<especialidadesCreateWithoutMedicosInput, especialidadesUncheckedCreateWithoutMedicosInput>
    where?: especialidadesWhereInput
  }

  export type especialidadesUpdateToOneWithWhereWithoutMedicosInput = {
    where?: especialidadesWhereInput
    data: XOR<especialidadesUpdateWithoutMedicosInput, especialidadesUncheckedUpdateWithoutMedicosInput>
  }

  export type especialidadesUpdateWithoutMedicosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type especialidadesUncheckedUpdateWithoutMedicosInput = {
    id_especialidad?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type citasCreateWithoutPacientesInput = {
    fecha: Date | string
    hora: Date | string
    estado_cita?: string | null
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
    medicos: medicosCreateNestedOneWithoutCitasInput
  }

  export type citasUncheckedCreateWithoutPacientesInput = {
    id_cita?: number
    id_medico: number
    fecha: Date | string
    hora: Date | string
    estado_cita?: string | null
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
  }

  export type citasCreateOrConnectWithoutPacientesInput = {
    where: citasWhereUniqueInput
    create: XOR<citasCreateWithoutPacientesInput, citasUncheckedCreateWithoutPacientesInput>
  }

  export type citasCreateManyPacientesInputEnvelope = {
    data: citasCreateManyPacientesInput | citasCreateManyPacientesInput[]
    skipDuplicates?: boolean
  }

  export type tipo_documentosCreateWithoutPacientesInput = {
    nombre: string
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
  }

  export type tipo_documentosUncheckedCreateWithoutPacientesInput = {
    id_tipo_documento?: number
    nombre: string
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
  }

  export type tipo_documentosCreateOrConnectWithoutPacientesInput = {
    where: tipo_documentosWhereUniqueInput
    create: XOR<tipo_documentosCreateWithoutPacientesInput, tipo_documentosUncheckedCreateWithoutPacientesInput>
  }

  export type citasUpsertWithWhereUniqueWithoutPacientesInput = {
    where: citasWhereUniqueInput
    update: XOR<citasUpdateWithoutPacientesInput, citasUncheckedUpdateWithoutPacientesInput>
    create: XOR<citasCreateWithoutPacientesInput, citasUncheckedCreateWithoutPacientesInput>
  }

  export type citasUpdateWithWhereUniqueWithoutPacientesInput = {
    where: citasWhereUniqueInput
    data: XOR<citasUpdateWithoutPacientesInput, citasUncheckedUpdateWithoutPacientesInput>
  }

  export type citasUpdateManyWithWhereWithoutPacientesInput = {
    where: citasScalarWhereInput
    data: XOR<citasUpdateManyMutationInput, citasUncheckedUpdateManyWithoutPacientesInput>
  }

  export type tipo_documentosUpsertWithoutPacientesInput = {
    update: XOR<tipo_documentosUpdateWithoutPacientesInput, tipo_documentosUncheckedUpdateWithoutPacientesInput>
    create: XOR<tipo_documentosCreateWithoutPacientesInput, tipo_documentosUncheckedCreateWithoutPacientesInput>
    where?: tipo_documentosWhereInput
  }

  export type tipo_documentosUpdateToOneWithWhereWithoutPacientesInput = {
    where?: tipo_documentosWhereInput
    data: XOR<tipo_documentosUpdateWithoutPacientesInput, tipo_documentosUncheckedUpdateWithoutPacientesInput>
  }

  export type tipo_documentosUpdateWithoutPacientesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tipo_documentosUncheckedUpdateWithoutPacientesInput = {
    id_tipo_documento?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pacientesCreateManyTipo_documentosInput = {
    id_paciente?: number
    nombres: string
    apellidos: string
    edad?: number | null
    fecha_nacimiento?: Date | string | null
    numero_documento: string
    direccion?: string | null
    correo?: string | null
    genero: string
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
  }

  export type pacientesUpdateWithoutTipo_documentosInput = {
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numero_documento?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    citas?: citasUpdateManyWithoutPacientesNestedInput
  }

  export type pacientesUncheckedUpdateWithoutTipo_documentosInput = {
    id_paciente?: IntFieldUpdateOperationsInput | number
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numero_documento?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    citas?: citasUncheckedUpdateManyWithoutPacientesNestedInput
  }

  export type pacientesUncheckedUpdateManyWithoutTipo_documentosInput = {
    id_paciente?: IntFieldUpdateOperationsInput | number
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numero_documento?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type medicosCreateManyEspecialidadesInput = {
    id_medico?: number
    nombres: string
    apellidos: string
    correo?: string | null
    celular?: string | null
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
  }

  export type medicosUpdateWithoutEspecialidadesInput = {
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    citas?: citasUpdateManyWithoutMedicosNestedInput
    horarios?: horariosUpdateManyWithoutMedicosNestedInput
  }

  export type medicosUncheckedUpdateWithoutEspecialidadesInput = {
    id_medico?: IntFieldUpdateOperationsInput | number
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    citas?: citasUncheckedUpdateManyWithoutMedicosNestedInput
    horarios?: horariosUncheckedUpdateManyWithoutMedicosNestedInput
  }

  export type medicosUncheckedUpdateManyWithoutEspecialidadesInput = {
    id_medico?: IntFieldUpdateOperationsInput | number
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type citasCreateManyMedicosInput = {
    id_cita?: number
    id_paciente: number
    fecha: Date | string
    hora: Date | string
    estado_cita?: string | null
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
  }

  export type horariosCreateManyMedicosInput = {
    id_horario?: number
    dia_semana: string
    hora_inicio: Date | string
    hora_fin: Date | string
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
  }

  export type citasUpdateWithoutMedicosInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_cita?: NullableStringFieldUpdateOperationsInput | string | null
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pacientes?: pacientesUpdateOneRequiredWithoutCitasNestedInput
  }

  export type citasUncheckedUpdateWithoutMedicosInput = {
    id_cita?: IntFieldUpdateOperationsInput | number
    id_paciente?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_cita?: NullableStringFieldUpdateOperationsInput | string | null
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type citasUncheckedUpdateManyWithoutMedicosInput = {
    id_cita?: IntFieldUpdateOperationsInput | number
    id_paciente?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_cita?: NullableStringFieldUpdateOperationsInput | string | null
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type horariosUpdateWithoutMedicosInput = {
    dia_semana?: StringFieldUpdateOperationsInput | string
    hora_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    hora_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type horariosUncheckedUpdateWithoutMedicosInput = {
    id_horario?: IntFieldUpdateOperationsInput | number
    dia_semana?: StringFieldUpdateOperationsInput | string
    hora_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    hora_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type horariosUncheckedUpdateManyWithoutMedicosInput = {
    id_horario?: IntFieldUpdateOperationsInput | number
    dia_semana?: StringFieldUpdateOperationsInput | string
    hora_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    hora_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type citasCreateManyPacientesInput = {
    id_cita?: number
    id_medico: number
    fecha: Date | string
    hora: Date | string
    estado_cita?: string | null
    estado_auditoria?: string | null
    fecha_creacion?: Date | string | null
    fecha_actualizacion?: Date | string | null
  }

  export type citasUpdateWithoutPacientesInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_cita?: NullableStringFieldUpdateOperationsInput | string | null
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicos?: medicosUpdateOneRequiredWithoutCitasNestedInput
  }

  export type citasUncheckedUpdateWithoutPacientesInput = {
    id_cita?: IntFieldUpdateOperationsInput | number
    id_medico?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_cita?: NullableStringFieldUpdateOperationsInput | string | null
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type citasUncheckedUpdateManyWithoutPacientesInput = {
    id_cita?: IntFieldUpdateOperationsInput | number
    id_medico?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_cita?: NullableStringFieldUpdateOperationsInput | string | null
    estado_auditoria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_actualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}